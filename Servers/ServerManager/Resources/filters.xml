<ServerManagerConfiguration>
  <ProxyGroup name="filters">

   <SourceProxy name="ImageShrink" class="vtkImageShrink3D">
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkImageData"/>
          </DataTypeDomain>
     </InputProperty>

     <IntVectorProperty 
        name="ShrinkFactors" 
        command="SetShrinkFactors" 
        number_of_elements="3"
        animateable="1"
        default_values="1 1 1" > 
       <IntRangeDomain name="range" min="1" max="100"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="Averaging" 
        command="SetAveraging" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
   <!-- End Stripper -->
   </SourceProxy>

   <SourceProxy name="SurfaceVectors" class="vtkSurfaceVectors">
     <Documentation
          long_help="This filter constrains vectors to lie on a surface."
          short_help="This filter constrains vectors o lie on a surface.">
The surface vectors filter is used for 2D data sets.  It constrains vectors to lie in a surface by removing components of the vectors normal to the local surface.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"
                             number_of_components="3"/>
      </InputProperty>

      <StringVectorProperty 
         name="SelectInputVectors" 
         command="SetInputArrayToProcess"
         number_of_elements="5"
         element_types="0 0 0 0 2"
         animateable="0"> 
            <ArrayListDomain name="array_list" attribute_type="Vectors">
              <RequiredProperties>
                 <Property name="Input" function="Input"/>
              </RequiredProperties>
            </ArrayListDomain>
      </StringVectorProperty> 

     <IntVectorProperty 
        name="ConstraintMode" 
        command="SetConstraintMode" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Parallel"/>
         <Entry value="1" text="Perpendicular"/>
         <Entry value="2" text="PerpendicularScale"/>
       </EnumerationDomain>
     </IntVectorProperty>

   <!-- End SurfaceVectors -->
   </SourceProxy>

   <SourceProxy name="IntegrateAttributes" class="vtkIntegrateAttributes">
     <Documentation 
        long_help="This filter integrates cell and point attributes.  Use selects whether the integration is over 1D lines, 2D surfaces or 3D volumes.  Cells not of the selected dimension are ignored."
        short_help="Integrates over lines, surfaces or vectors.">
Integrates point and cell data over lines and surfaces.  It also computes length of lines, area of surface or volume.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
      </InputProperty>
   <Hints>
     <Visibility replace_input="0" />
   </Hints>
   <!-- End IntegrateAttributes -->
   </SourceProxy>

   <SourceProxy name="IntegrateFlowThroughSurface" class="vtkIntegrateFlowThroughSurface">
     <Documentation
        long_help="This filter integrates flow through a surface."
        short_help="This filter integrates flow through a surface.">
The flow integration fitler  integrates the dot product of a point flow vector field and surface normal.  It computes the net flow across the 2D surface..
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type" composite_data_supported="0">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"
                             number_of_components="3"/>
      </InputProperty>

      <StringVectorProperty 
         name="SelectInputVectors" 
         command="SetInputArrayToProcess"
         number_of_elements="5"
         element_types="0 0 0 0 2">
            <ArrayListDomain name="array_list" attribute_type="Vectors">
              <RequiredProperties>
                 <Property name="Input" function="Input"/>
              </RequiredProperties>
            </ArrayListDomain>
      </StringVectorProperty> 

   <!-- End IntegrateFlowThroughSurface -->
   </SourceProxy>

   <SourceProxy name="AllToN" class="vtkAllToNRedistributePolyData">
      <Documentation
         long_help="Redistribute data to a subset of available processes."
         short_help="Repartition data filter.">
The All to N filter is available when ParaView is run in parallel. It redistributes the data so that it is located on the number of processes specified in the Number of Processes entry box. It also does load-balancing of the data among these processes. This filter operates on polygonal data and produces polygonal output.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
      </InputProperty>

      <IntVectorProperty 
         name="NumberOfProcesses" 
         command="SetNumberOfProcesses" 
         number_of_elements="1"
         default_values="1" > 
      </IntVectorProperty>         
   <!-- End AllToN -->
   </SourceProxy>

   <SourceProxy name="Balance" class="vtkBalancedRedistributePolyData">
      <Documentation
         long_help="Balance data among available processes."
         short_help="Load balance filter.">
The Balance filter is available when ParaView is run in parallel. It does load-balancing so that all processes have the same number of cells. It operates on polygonal data sets and produces polygonal output.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
      </InputProperty>
   <!-- End Balance -->
   </SourceProxy>

   <SourceProxy name="AppendAttributes" class="vtkMergeArrays">
      <Documentation
         long_help="Copies geometry from first input.  Puts all of the arrays into the output."
         short_help="Puts all input arrays into the single output.">
The Append Attributes filter takes multiple input data sets with the same geometry and merges their point and cell attributes to produce a single output containing all the point and cell attributes of the inputs. Any inputs without the same number of points and cells as the first input are ignored. The input data sets must already be collected together, either as a result of a reader that loads multiple parts (e.g., EnSight reader) or because the Group Parts filter has been run to form a collection of data sets.
      </Documentation>
      <InputProperty
         name="Input"
         command="AddInputConnection"
         clean_command="RemoveAllInputs"
         multiple_input="1">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type" composite_data_supported="0">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
      </InputProperty>
         
   <!-- End AppendAttributes -->
   </SourceProxy>

   <SourceProxy name="AppendPolyData" class="vtkAppendPolyData">
      <Documentation
         long_help="Takes an input of multiple poly data parts and output has only one part."
         short_help="Append multiple parts into one.">
The Append Geometry filter operates on multiple polygonal data sets. The data sets must already be collected together, either as a result of a reader that loads multiple parts (e.g., EnSight reader) or because the Group Parts filter has been run to form a collection of data sets. It merges their geometry into a single data set. Only the point and cell attributes that all of the input data sets have in common will appear in the output.
      </Documentation>
      <InputProperty
         name="Input"
         command="AddInputConnection"
         clean_command="RemoveAllInputs"
         multiple_input="1">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
      </InputProperty>
   <!-- End AppendPolyData -->
   </SourceProxy>

   <SourceProxy name="Append" class="vtkAppendFilter">
      <Documentation
         long_help="Takes an input of multiple datasets and output has only one unstructured grid."
         short_help="Append multiple datasets into one.">
The Append Datasets filter operates on multiple data sets of any type (polygonal, structured, etc.). It merges their geometry into a single data set. Only the point and cell attributes that all of the input data sets have in common will appear in the output. The input data sets must already be collected together, either as a result of a reader that loads multiple parts (e.g., EnSight reader) or because the Group Parts filter has been run to form a collection of data sets.
      </Documentation>
      <InputProperty
         name="Input"
         command="AddInputConnection"
         clean_command="RemoveAllInputs"
         multiple_input="1">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type" composite_data_supported="0">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
      </InputProperty>
   <!-- End AppendDataSet -->
   </SourceProxy>

   <SourceProxy name="CellCenters" class="vtkCellCenters">
     <Documentation
        long_help="Create a point (no geometry) at the center of each input cell."
        short_help="Convert cells to vertices.">
The Cell Centers filter places a point at the center of each cell in the input data set. The center computed is the parametric center of the cell, not necessarily the geometric or bounding box center. The cell attributes of the input will be associated with these newly created points of the output. The Input menu allows the user to select the data set to which this filter will be applied. If the Generate vertices option is checked, then vertex cells will also be created for each point in the output. This is useful because vertex cells are rendered, but points are not. The points themselves could be used for placing glyphs (using the Glyph filter). The Cell Centers filter takes any type of data set as input and produces a polygonal data set as output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
     </InputProperty>

     <IntVectorProperty 
        name="VertexCells" 
        command="SetVertexCells" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
   <!-- End CellCenters -->
   </SourceProxy>

   <SourceProxy name="CellDataToPointData" class="vtkPCellDataToPointData">
     <Documentation
        long_help="Create point attributes by averaging cell attributes."
        short_help="Convert cell data to point data.">
The Cell Data to Point Data filter averages the values of the cell attributes of the cells surrounding a point to compute point attributes. The Input menu allows the user to select the data set to which this filter will be applied. If the Pass cell data option is checked, then the input cell attributes will also be copied to the cell attributes of the output; otherwise the output will only have point attributes. The Cell Data to Point Data filter operates on any type of data set, and the output data set is of the same type as the input.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="cell"/>
     </InputProperty>

     <IntVectorProperty 
        name="PassCellData" 
        command="SetPassCellData" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
   <!-- End CellDataToPointData -->
   </SourceProxy>

   <SourceProxy name="PointDataToCellData" class="vtkPointDataToCellData">
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"/>
           <FixedTypeDomain name="fixed_type"/>
      </InputProperty>

     <IntVectorProperty 
        name="PassPointData" 
        command="SetPassPointData" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
   <!-- End CellDataToPointData -->
   </SourceProxy>

   <SourceProxy name="CleanPolyData" class="vtkCleanPolyData">
     <Documentation
        long_help="Merge coincident points if they do not meet a feature edge critera."
        short_help="Merge coincident points.">
The Clean filter takes polygonal data as input and generates polygonal data as output. This filter can merge duplicate points, remove unused points, and transform degenerate cells into their appropriate forms (e.g., a triangle is converted into a line if two of its points are merged). The Input menu allows the user to select the data set to which this filter will be applied. If the Point merging option is on, then points will be merged if they are within the specified Tolerance or Absolute tolerance, depending on whether the Tolerance is absolute box is checked. (Tolerance is specified as a fraction of the length of the diagonal of the bounding box of the data set; Absolute tolerance is specified in the spatial units of the input data set.)
The transforming of degenerate cells into their appropriate forms is controlled by three check boxes on the user interface: Convert lines to points, Convert polys to lines, and Convert strips to polys. If any of these is unchecked, then degenerate cells of that type will not be converted to another type of cell.
If the Piece invariant option is checked, the whole data set will be processed at once so that cleaning this data set always produces the same results. If the box is unchecked, the data set can be processed one piece at a time, so it is not necessary for the entire data set to fit into memory, but the results are not guaranteed to be the same as they would be if the Piece invariant option was on.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
     </InputProperty>

     <IntVectorProperty 
        name="PieceInvariant" 
        command="SetPieceInvariant" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="Tolerance"
        command="SetTolerance"
        number_of_elements="1"
        animateable="1"
        default_values="0.0" >
       <DoubleRangeDomain name="range" min="0" max="1" />
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="AbsoluteTolerance"
        command="SetAbsoluteTolerance"
        number_of_elements="1"
        default_values="1.0" >
       <DoubleRangeDomain name="range" min="0"/>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="ToleranceIsAbsolute" 
        command="SetToleranceIsAbsolute" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ConvertLinesToPoints" 
        command="SetConvertLinesToPoints" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ConvertPolysToLines" 
        command="SetConvertPolysToLines" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ConvertStripsToPolys" 
        command="SetConvertStripsToPolys" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="PointMerging" 
        command="SetPointMerging" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
   <!-- End CleanPolyData -->
   </SourceProxy>

   <SourceProxy name="CleanUnstructuredGrid" class="vtkCleanUnstructuredGrid">
      <Documentation
         long_help="This filter merges points and converts the data set to unstructured grid."
         short_help="Merge points.">
The Clean to Grid filter merges points that are within a tolerance of 1/100,000 of the length of the diagonal of the bounding box of the data set. It also converts the data set to an unstructured grid. You may wish to do this if you want to apply a filter to your data set that is available for unstructured grids but not for the initial type of your data set (e.g., applying warp vector to volumetric data). The Input menu allows the user to select the data set to which this filter will be applied. The Clean to Grid filter operates on any type of data set.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
      </InputProperty>
   <!-- End CleanUnstructuredGrid -->
   </SourceProxy>

   <SourceProxy name="Delaunay2D" class="vtkDelaunay2D">
      <Documentation
         long_help="Create 2D Delaunay triangulation of input points. 
It expects a vtkPointSet as input and produces vtkPolyData as output. 
The points are expected to be in a mostly planar distribution."
         short_help="Create 2D Delaunay triangulation of input points.">
Delaunay2D is a filter that constructs a 2D Delaunay triangulation from 
a list of input points. These points may be represented by any dataset 
of type vtkPointSet and subclasses. The output of the filter is a 
polygonal dataset containing a triangle mesh.

The 2D Delaunay triangulation is defined as the triangulation that 
satisfies the Delaunay criterion for n-dimensional simplexes (in this 
case n=2 and the simplexes are triangles). This criterion states that a 
circumsphere of each simplex in a triangulation contains only the n+1 
defining points of the simplex. (See "The Visualization Toolkit" text 
for more information.) In two dimensions, this translates into an 
optimal triangulation. That is, the maximum interior angle of any 
triangle is less than or equal to that of any possible triangulation.

Delaunay triangulations are used to build topological structures from 
unorganized (or unstructured) points. The input to this filter is a list 
of points specified in 3D, even though the triangulation is 2D. Thus the 
triangulation is constructed in the x-y plane, and the z coordinate is 
ignored (although carried through to the output). You can use the option
ProjectionPlaneMode in order to compute the best-fitting plane to the
set of points, project the points and that plane and then perform the
triangulation using their projected positions and then use it as the 
plane in which the triangulation is performed.

The Delaunay triangulation can be numerically sensitive in some cases. 
To prevent problems, try to avoid injecting points that will result in 
triangles with bad aspect ratios (1000:1 or greater). In practice this 
means inserting points that are "widely dispersed", and enables smooth 
transition of triangle sizes throughout the mesh. (You may even want to 
add extra points to create a better point distribution.) If numerical 
problems are present, you will see a warning message to this effect at 
the end of the triangulation process.

Warning:
     Points arranged on a regular lattice (termed degenerate cases) can 
be triangulated in more than one way (at least according to the Delaunay 
criterion). The choice of triangulation (as implemented by this 
algorithm) depends on the order of the input points. The first three 
points will form a triangle; other degenerate points will not break this 
triangle.

     Points that are coincident (or nearly so) may be discarded by the 
algorithm. This is because the Delaunay triangulation requires unique 
input points. The output of the Delaunay triangulation is supposedly a 
convex hull. In certain cases this implementation may not generate the 
convex hull.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPointSet"/>
           </DataTypeDomain>
      </InputProperty>
      <IntVectorProperty 
        name="ProjectionPlaneMode" 
        command="SetProjectionPlaneMode" 
        number_of_elements="1"
        default_values="0"> 
       <IntRangeDomain name="range" min="0" max="2"/>
     </IntVectorProperty>
     <DoubleVectorProperty name="Alpha"
       command="SetAlpha"
       number_of_elements="1"
       animateable="1"
       default_values="0.0">
       <DoubleRangeDomain name="range" min="0"/>
     </DoubleVectorProperty>
     <DoubleVectorProperty name="Tolerance"
       command="SetTolerance"
       number_of_elements="1"
       animateable="1"
       default_values="0.00001">
       <DoubleRangeDomain name="range" min="0" max="1.0" />
     </DoubleVectorProperty>
     <DoubleVectorProperty name="Offset"
       command="SetOffset"
       number_of_elements="1"
       animateable="1"
       default_values="1.0">
       <DoubleRangeDomain name="range" min="0.75"/>
     </DoubleVectorProperty>
     <IntVectorProperty name="BoundingTriangulation"
       command="SetBoundingTriangulation"
       number_of_elements="1"
       animateable="1"
       default_values="0">
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
   </SourceProxy>

   <SourceProxy name="PVConnectivityFilter" class="vtkPVConnectivityFilter">
      <Documentation
          long_help="Mark connected components with integer point attribute array."
          short_help="Find connected components.">
The Connectivity filter assigns a region id to connected components of the input data set. (The region id is assigned as a point scalar value.) The Input menu allows the user to select the data set to which this filter will be applied. This filter takes any data set type as input and produces unstructured grid output.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
      </InputProperty>
   <!-- End PVConnectivityFilter -->
   </SourceProxy>

   <SourceProxy name="ImageClip" class="vtkImageClip">
    <Documentation
       long_help="Efficiently extract an area/volume of interest from a 2-d image or 3-d volume."
       short_help="Extract a volume of interest.">
The Crop filter extracts an area/volume of interest from a 2D image or a 3D volume by allowing the user to specify the minimum and maximum extents of each dimension of the data. The Input menu allows the user to select the data set to which this filter will be applied. Both the input and output of this filter are uniform rectilinear data.
    </Documentation>

    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkImageData"/>
          </DataTypeDomain>
     </InputProperty>

     <IntVectorProperty 
        name="OutputWholeExtent" 
        command="SetOutputWholeExtent" 
        number_of_elements="6"
        default_values="0 0 0 0 0 0"> 
       <ExtentDomain name="extent">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </ExtentDomain>
     </IntVectorProperty>
    <Hints>
      <Visibility replace_input="0" />
    </Hints>
   <!-- End ImageClip -->
   </SourceProxy>

   <SourceProxy name="Curvatures" class="vtkCurvatures">
    <Documentation
       long_help="This filter will compute the gaussian or mean curvature of the mesh at each point."
       short_help="Compute the curvature at each point.">
The Curvature filter computes the curvature at each point in a polygonal data set. This filter supports both Gaussian and mean curvatures; the type can be selected from the Curvature type menu button. The Input menu allows the user to select the data set to which this filter will be applied. If the Invert mean curvature option is checked, the mean curvature calculation will be inverted. This is useful for meshes with inward-pointing normals.
    </Documentation>

    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
     </InputProperty>

     <IntVectorProperty 
        name="InvertMeanCurvature" 
        command="SetInvertMeanCurvature" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="CurvatureType" 
        command="SetCurvatureType" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Gaussian"/>
         <Entry value="1" text="Mean"/>
       </EnumerationDomain>
     </IntVectorProperty>
   <!-- End Curvatures -->
   </SourceProxy>

   <SourceProxy name="DecimatePro" class="vtkDecimatePro">
     <Documentation
        long_help="Simplify a polygonal model using an adaptive edge collapse algorithm.  This filter works with triangles only."
        short_help="Reduce the number of triangles in a model.">
The Decimate filter reduces the number of triangles in a polygonal data set. Because this filter only operates on triangles, first run the Triangulate filter on a data set that contains polygons other than triangles. The Input menu allows the user to select the data set to which this filter will be applied. The Reduction target slider specifies the desired reduction in the total number of polygons (e.g., if the Reduction target value is 0.9, the Decimate filter will attempt to produce an output data set that is 10% the size of the input.) If the Preserve topology option is on, decimation will not split the data set or produce holes, but it may keep the filter from reaching the reduction target. The Feature angle slider value is used in determining where the data set may be split. If the angle between two adjacent triangles is >= the Feature angle value, then their boundary is considered a feature edge where the data set can be split. If the Boundary deletable option is on, then vertices on the boundary of the data set can be removed. Turning this option off preserves the boundary of the data set, but it may cause the filter not to reach its reduction target.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
      </InputProperty>

      <DoubleVectorProperty
         name="TargetReduction"
         command="SetTargetReduction"
         number_of_elements="1"
         animateable="1"
         default_values="0.9" >
        <DoubleRangeDomain name="range" min="0" max="1" />
      </DoubleVectorProperty>

     <IntVectorProperty 
        name="PreserveTopology" 
        command="SetPreserveTopology" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="FeatureAngle"
        command="SetFeatureAngle"
        number_of_elements="1"
        default_values="15.0" >
       <DoubleRangeDomain name="range" min="0" max="180" />
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="BoundaryVertexDeletion" 
        command="SetBoundaryVertexDeletion" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
   <!-- End DecimatePro -->
   </SourceProxy>

   <SourceProxy name="D3" class="vtkDistributedDataFilter">
    <Documentation
       long_help="Repartition a data set into load-balanced spatially convex regions.  Create ghost cells if requested."
       short_help="Repartition a data set.">
The D3 filter is available when ParaView is run in parallel. It operates on any type of data set to evenly divide it across the processors into spatially contiguous regions. The Boundary Cells menu determines how cells that lie on processor boundaries are handled. The Assign cells uniquely option assigns each boundary cell to exactly one process, which is useful for isosurfacing. Selecting Duplicate cells causes the cells on the boundaries to be copied to each process that shares that boundary. The Divide cells option breaks cells across process boundary lines so that pieces of the cell lie in different processes. This option is useful for volume rendering. The output of this filter is of type unstructured grid.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
     </InputProperty>

     <IntVectorProperty 
        name="BoundaryMode" 
        command="SetBoundaryMode" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Assign cells uniquely"/>
         <Entry value="1" text="Duplicate cells"/>
         <Entry value="2" text="Divide cells"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <IntVectorProperty 
        name="UseMinimalMemory" 
        command="SetUseMinimalMemory" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
   <!-- End D3 -->
   </SourceProxy>

   <SourceProxy name="ElevationFilter" class="vtkElevationFilter">
     <Documentation
        long_help="Create point attribute array by projecting points onto an elevation vector."
        short_help="Create a point array representing elevation.">
The Elevation filter generates point scalar values for an input data set along a specified direction vector. The Input menu allows the user to select the data set to which this filter will be applied. Use the Scalar range entry boxes to specify the minimum and maximum scalar value to be generated. The Low Point and High Point define a line onto which each point of the data set is projected. The minimum scalar value is associated with the Low Point, and the maximum scalar value is associated with the High Point. The scalar value for each point in the data set is determined by the location along the line to which that point projects.
The line can be specified interactively using the 3D line widget. See section 7.4 for more information about this widget.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
      </InputProperty>

      <DoubleVectorProperty
         name="ScalarRange"
         command="SetScalarRange"
         number_of_elements="2"
         default_values="0 1" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          Specify range to map scalars into. Default is [0, 1].
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="LowPoint"
         command="SetLowPoint"
         number_of_elements="3"
         animateable="1"
         default_values="0 0 0" >
         <Documentation>
           Define one end of the line (small scalar values). Default is (0,0,0).
         </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="HighPoint"
         command="SetHighPoint"
         number_of_elements="3"
         animateable="1"
         default_values="0 0 1" >
         <Documentation>
           Define other end of the line (large scalar values). Default is (0,0,1).
         </Documentation>
      </DoubleVectorProperty>
   <!-- End ElevationFilter -->
   </SourceProxy>

#if 1
   <SourceProxy name="CTHPart" class="vtkExtractCTHPart">
    <Documentation
       long_help="Create a surface from a CTH volume fraction."
       short_help="Extract a part from a CTH dataset.">
Extract CTH Parts is a specialized filter for visualizing the data from a CTH simulation. It first converts the selected cell-centered arrays to point-centered ones. It then contours each array at a value of 0.5. The user has the option of clipping the resulting surface(s) with a plane.
If the Show All option is on, all the cell-centered scalar (single-component) arrays will be displayed in the array selection box; otherwise only the ones with "Fraction" or "fraction" in the name will be shown. (This behavior is because by default the CTH volume fraction arrays should be listed.) Clicking on the name of a particular array selects it. To choose multiple contiguous array names, click the first one and press the Shift key while clicking the last name you wish to select. If the names are not contiguous, press the Ctrl key while selecting the names from the list. The selected arrays will be contoured.
If you wish to clip the contour surfaces with a plane, select On from the menu in the Clipping section on this Parameters tab. You can interactively position and orient the plane using the plane widget. (See section 7.4 for the details of using this widget or manually setting the plane's parameters.)
This filter only operates on unstructured data. It produces polygonal output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="cell" 
                            number_of_components="1"/>
     </InputProperty>

     <ProxyProperty name="ClipPlane" command="SetClipPlane">
           <ProxyGroupDomain name="groups">
              <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="Plane" />
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
           </ProxyListDomain>
     </ProxyProperty>

     <StringVectorProperty 
        name="AddVolumeArrayName" 
        command="AddVolumeArrayName" 
        repeat_command="1"
        number_of_elements_per_command="1"
        number_of_elements="1" /> 

     <DoubleVectorProperty
        name="VolumeFractionSurfaceValue"
        command="SetVolumeFractionSurfaceValue"
        number_of_elements="1"
        default_values="0.1" >
       <DoubleRangeDomain name="range" min="0" max="1" />
     </DoubleVectorProperty>
   <!-- End CTHPart -->
   </SourceProxy>
#endif

   <SourceProxy name="ExtractEdges" class="vtkExtractEdges">
     <Documentation
        long_help="Extract edges of 2-d and 3-d cells as lines."
        short_help="Covert data to wireframe.">
The Extract Edges filter produces a wireframe version of the input data set by extracting all the edges of the data set's cells as lines. The Input menu allows the user to select the data set to which this filter will be applied. This filter operates on any type of data set and produces polygonal output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
      </InputProperty>
   <!-- End ExtractEdges -->
   </SourceProxy>

   <SourceProxy name="DataSetSurfaceFilter" class="vtkDataSetSurfaceFilter">
     <Documentation
        long_help="Extract a 2-d boundary surface using neighbor relations to eliminate internal faces."
        short_help="Extract 2-d boundary surface.">
The Extract Surface filter extracts the polygons forming the outer surface of the input data set. The Input menu allows the user to select the data set to which this filter will be applied. This filter operates on any type of data and produces polygonal data as output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
      </InputProperty>

     <IntVectorProperty 
        name="PieceInvariant" 
        command="SetPieceInvariant" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
   <!-- End DataSetSurfaceFilter -->
   </SourceProxy>

   <SourceProxy name="Calculator" class="vtkArrayCalculator">
    <Documentation
       long_help="Compute new attribute arrays as function of existing arrays."
       short_help="Compute new attribute arrays.">
The Calculator filter computes new data arrays as functions of existing scalar or vector arrays. The Input menu allows the user to select the data set to which this filter will be applied. The Result Array Name entry box allows the user to specify the name of the array containing the results of the computation. The Attribute Mode menu selects whether to operate on and produce results that are point-centered or cell-centered. If point-centered arrays are used, the resulting array will also be point-centered. The same is true for cell-centered arrays. The Calculator interface operates similarly to a scientific calculator. In creating the function to evaluate, the standard order of operations applies.
Each of the calculator functions is described below. Unless otherwise noted, enclose the operand in parentheses using the ( and ) buttons.
Clear: Erase the current function (displayed in the read-only text box above the calculator buttons).
/: Divide one scalar by another. The operands for this function are not required to be enclosed in parentheses.
*: Multiply two scalars, or multiply a vector by a scalar (scalar multiple). The operands for this function are not required to be enclosed in parentheses.
-: Negate a scalar or vector (unary minus), or subtract one scalar or vector from another. The operands for this function are not required to be enclosed in parentheses.
+: Add two scalars or two vectors. The operands for this function are not required to be enclosed in parentheses.
sin: Compute the sine of a scalar.
cos: Compute the cosine of a scalar.
tan: Compute the tangent of a scalar.
asin: Compute the arcsine of a scalar.
acos: Compute the arccosine of a scalar.
atan: Compute the arctangent of a scalar.
sinh: Compute the hyperbolic sine of a scalar.
cosh: Compute the hyperbolic cosine of a scalar.
tanh: Compute the hyperbolic tangent of a scalar.
x^y: Raise one scalar to the power of another scalar. The operands for this function are not required to be enclosed in parentheses.
sqrt: Compute the square root of a scalar.
e^x: Raise e to the power of a scalar.
log: Compute the logarithm of a scalar.
ceil: Compute the ceiling of a scalar.
floor: Compute the floor of a scalar.
abs: Compute the absolute value of a scalar.
v1.v2: Compute the dot product of two vectors. The operands for this function are not required to be enclosed in parentheses.
mag: Compute the magnitude of a vector.
norm: Normalize a vector.
The operands are described below.
The digits 0 - 9 and the decimal point are used to enter constant scalar values.
iHat, jHat, and kHat are vector constants representing unit vectors in the X, Y, and Z directions, respectively.
The scalars menu lists the names of the scalar arrays and the components of the vector arrays of either the point-centered or cell-centered data. The vectors menu lists the names of the point-centered or cell-centered vector arrays. The function will be computed for each point (or cell) using the scalar or vector value of the array at that point (or cell).
The filter operates on any type of data set, but the input data set must have at least one scalar or vector array. The arrays can be either point-centered or cell-centered. The Calculator filter's output is of the same data set type as the input.
The Calculator filter is available on the Toolbar.
    </Documentation>

    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array"/>
     </InputProperty>

     <Property
        name="RemoveAllVariables"
        command="RemoveAllVariables"
        immediate_update="1">
     </Property>

     <StringVectorProperty 
        name="ResultArrayName" 
        command="SetResultArrayName" 
        number_of_elements="1"
        default_values="Result" /> 
     
     <StringVectorProperty 
        name="Function" 
        command="SetFunction" 
        number_of_elements="1" /> 
   
     <StringVectorProperty 
        name="AddScalarVariable" 
        command="AddScalarVariable" 
        clean_command="RemoveScalarVariables"
        number_of_elements="0" 
        repeat_command="1"
        number_of_elements_per_command="3"
        element_types="2 2 0" />

     <StringVectorProperty 
        name="AddVectorVariable" 
        command="AddVectorVariable" 
        clean_command="RemoveVectorVariables"
        number_of_elements="0" 
        repeat_command="1"
        number_of_elements_per_command="5"
        element_types="2 2 0 0 0" />
     
        <StringVectorProperty 
        name="AddCoordinateScalarVariable" 
        command="AddCoordinateScalarVariable" 
        clean_command="RemoveCoordinateScalarVariables"
        number_of_elements="0" 
        repeat_command="1"
        number_of_elements_per_command="2"
        element_types="2 0" />

     <StringVectorProperty 
        name="AddCoordinateVectorVariable" 
        command="AddCoordinateVectorVariable" 
        clean_command="RemoveCoordinateVectorVariables"
        number_of_elements="0" 
        repeat_command="1"
        number_of_elements_per_command="4"
        element_types="2 0 0 0" />

     <IntVectorProperty 
        name="CoordinateResults" 
        command="SetCoordinateResults" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="AttributeMode" 
        command="SetAttributeMode" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="1" text="point_data"/>
         <Entry value="2" text="cell_data"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ReplaceInvalidValues" 
        command="SetReplaceInvalidValues" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="ReplacementValue"
        command="SetReplacementValue"
        number_of_elements="1"
        default_values="0.0" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>
   <!-- End Calculator -->
   </SourceProxy>

   <SourceProxy name="FeatureEdges" class="vtkFeatureEdges">
    <Documentation
       long_help="This filter will extract edges along sharp edges of surfaces or boundaries of surfaces."
       short_help="Extract edges that meet the feature critera.">
The Feature Edges filter extracts various subsets of edges from the input data set. Which edges are extracted depends on which check boxes are marked. The four types of edges are as follows.
Boundary edges: line cells or edges used by only one polygon
Feature edges: edges used by two polygons whose dihedral angle > the value from the Feature angle slider
Non-manifold edges: edges used by three or more polygons
Manifold edges: edges used by exactly two polygons
If the Coloring option is checked, then the extracted edges are assigned a scalar value based on the type of the edge. The Input menu allows the user to select the data set to which this filter will be applied.
This filter operates on polygonal data and produces polygonal output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
     </InputProperty>

     <IntVectorProperty 
        name="BoundaryEdges" 
        command="SetBoundaryEdges" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="FeatureEdges" 
        command="SetFeatureEdges" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="NonManifoldEdges" 
        command="SetNonManifoldEdges" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ManifoldEdges" 
        command="SetManifoldEdges" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="Coloring" 
        command="SetColoring" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="FeatureAngle"
        command="SetFeatureAngle"
        number_of_elements="1"
        default_values="30.0" >
       <DoubleRangeDomain name="range" min="0" max="180" />
     </DoubleVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End FeatureEdges -->
   </SourceProxy>

   <SourceProxy name="Gradient" class="vtkImageGradient">
    <Documentation>
The Gradient filter computes the gradient vector at each point in an image or volume. The Input menu allows the user to select the data set to which this filter will be applied. The Scalars menu determines from which scalar array the gradient will be computed. The Dimensionality menu selects whether the gradient will be calculated in 2 or 3 dimensions. If only 2 dimensions are used, gradients are only computed in X and Y. This filter uses central differences to compute the gradients. The Gradient filter operates on uniform rectilinear (image) data and produces image data output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkImageData"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point" 
                            number_of_components="1"/>
     </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
          number_of_elements="5"
          element_types="0 0 0 0 2">
           <ArrayListDomain name="array_list" attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
     </StringVectorProperty>
     <IntVectorProperty 
        name="Dimensionality" 
        command="SetDimensionality" 
        number_of_elements="1"
        default_values="3" >
       <EnumerationDomain name="enum">
         <Entry value="2" text="Two"/>
         <Entry value="3" text="Three"/>
       </EnumerationDomain>
     </IntVectorProperty>
   <!-- End Gradient -->
   </SourceProxy>

   <SourceProxy name="UnstructuredGradient" class="vtkGradientFilter">
     <Documentation>
The Gradient filter estimates the gradient vector at each point or cell.  The Input menu allows the user to select the data set to which this filter will be applied.  The Field and Scalars menus allow the user to select the scalar array from which to compute gradients.  The Scalars menu determines from which scalar array the gradient will be computed.  The Result Array Name box allows the user to specify the name of the output array holding the computed gradients.
     </Documentation>
     <InputProperty name="Input" command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkPointSet"/>
       </DataTypeDomain>
       <InputArrayDomain name="input_array" number_of_components="1">
         <RequiredProperties>
           <Property name="SelectInputScalars" function="FieldDataSelection"/>
         </RequiredProperties>
       </InputArrayDomain>
     </InputProperty>

     <StringVectorProperty name="SelectInputScalars"
                           command="SetInputArrayToProcess"
                           number_of_elements="5"
                           element_types="0 0 0 0 2">
       <ArrayListDomain name="array_list" attribute_type="Scalars">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </ArrayListDomain>
       <FieldDataDomain name="field_list">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </FieldDataDomain>
     </StringVectorProperty>
     <StringVectorProperty name="ResultArrayName"
                           command="SetResultArrayName"
                           number_of_elements="1"
                           default_values="Gradients"/>
   <!-- End UnstructuredGradient -->
   </SourceProxy>

   <SourceProxy name="GradientMagnitude" class="vtkImageGradientMagnitude">
     <Documentation>
The Gradient Magnitude filter computes the magnitude of the gradient vector at each point in an image or volume. The Input menu allows the user to select the data set to which this filter will be applied. The Scalars menu allows the user to select which scalar array will be used for gradient magnitude calculations. The Dimensionality menu determines whether the gradient magnitude will be computed in 2 or 3 dimensions. If 2 dimensions are used, the gradient magnitude will be computed from the gradients in X and Y. This filter operates on uniform rectilinear (image) data and produces image data output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkImageData"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point" 
                             number_of_components="1"/>
      </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2">
            <ArrayListDomain name="array_list" attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
     </StringVectorProperty>

     <IntVectorProperty 
        name="Dimensionality" 
        command="SetDimensionality" 
        number_of_elements="1"
        default_values="3" >
       <EnumerationDomain name="enum">
         <Entry value="2" text="Two"/>
         <Entry value="3" text="Three"/>
       </EnumerationDomain>
     </IntVectorProperty>
   <!-- End Gradient -->
   </SourceProxy>

   <SourceProxy name="LinearExtrusionFilter" class="vtkPVLinearExtrusionFilter">
    <Documentation
       long_help="This filter creates a swept surface defined by translating the input along a vector."
       short_help="Generate a linear swept surface.">
The Linear Extrusion filter creates a swept surface by translating the input data set along a specified vector. This filter is intended to operate on 2D polygonal data. The Input menu allows the user to select the data set to which this filter will be applied. The three Vector entry boxes specify the X, Y, and Z components of the vector along which to sweep the input. The value of the Scale factor entry determines the distance along the vector the data set will be translated. (A scale factor of 0.5 will move the data set half the length of the vector, and a scale factor of 2 will move it twice the vector's length.)
The Capping check box indicates whether to cap the ends of the swept surface. Capping works by placing a copy of the input data set on either end of the swept surface, so it behaves properly if the input is a 2D surface composed of filled polygons. If the input data set is a closed solid (e.g., a sphere), then if capping is on, two copies of the data set will be displayed on output (the second translated from the first one along the specified vector). If instead capping is off, then an input closed solid will produce no output.
The Piece invariant check box determines whether the output will be the same regardless of the number of processors used to compute the result. The difference is whether there are internal polygonal faces on the processor boundaries. This filter operates on polygonal data and produces polygonal data output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
     </InputProperty>

     <DoubleVectorProperty
        name="ScaleFactor"
        command="SetScaleFactor"
        number_of_elements="1"
        animateable="1"
        default_values="1.0" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="Vector"
        command="SetVector"
        number_of_elements="3"
        default_values="0 0 1" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="Capping" 
        command="SetCapping" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="PieceInvariant" 
        command="SetPieceInvariant" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
   <!-- End LinearExtrusionFilter -->
   </SourceProxy>

   <SourceProxy name="LoopSubdivisionFilter" class="vtkLoopSubdivisionFilter">
    <Documentation
       long_help="This filter iteratively divides each triangle into four triangles.  New points are placed so the output surface is smooth."
       short_help="Create a higher resolution and smoother surface.">
The Loop Subdivision filter increases the granularity of a polygonal mesh. It works by dividing each triangle in the input into four new triangles. It is named for Charles Loop, the person who devised this subdivision scheme. This filter only operates on triangles, so a data set that contains other types of polygons should be passed through the Triangulate filter before applying this filter to it. The Input menu allows the user to select the data set to which this filter will be applied. The Number of divisions slider specifies the number of subdivision iterations to be performed. (For example, if the number of divisions is 2, the triangles in the initial mesh will each be divided into four new triangles. Then those new triangles will be further subdivided.) This filter only operates on polygonal data (specifically triangle meshes), and it produces polygonal output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
     </InputProperty>

     <IntVectorProperty 
        name="NumberOfSubdivisions" 
        command="SetNumberOfSubdivisions" 
        number_of_elements="1"
        animateable="1"
        default_values="1" > 
       <IntRangeDomain name="range" min="1" max="4"/>
     </IntVectorProperty>
   <!-- End LoopSubdivisionFilter -->
   </SourceProxy>

   <SourceProxy name="MaskPoints" class="vtkMaskPoints">
    <Documentation
          long_help="Reduce the number of points.  This filter is often used before glyphing.  Generating vertices is an option."
          short_help="Reduce the number of points.">
The Mask Points filter reduces the number of points in the data set. It operates on any type of data set, but produces only points / vertices. This filter is often used before the Glyph filter, but now the basic point-masking functionality is available on the Parameters page for the Glyph filter.
The Input menu allows the user to select the data set to which this filter will be applied. The value in the On ratio thumb wheel specifies the ratio of points to retain in the output. (For example, if the on ratio is 3, then the output will contain 1/3 as many points -- up to the Max. points value -- as the input.) The Max. points thumb wheel determines the maximum number of points that will appear in the output. The Offset thumb wheel specifies the point in the data set from which to start masking. If the Random check box is marked, then the output points will be selected randomly from the input; otherwise every nth point (specified by the on ratio) will be selected. Selecting points at random is helpful to avoid striping when masking the points of a structured data set. If the Generate vertices option is checked, then a vertex cell will be created for each point in the output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
     </InputProperty>

     <IntVectorProperty 
        name="OnRatio" 
        command="SetOnRatio" 
        number_of_elements="1"
        default_values="2" > 
       <IntRangeDomain name="range" min="1"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="MaximumNumberOfPoints" 
        command="SetMaximumNumberOfPoints" 
        number_of_elements="1"
        default_values="5000" > 
       <IntRangeDomain name="range" min="0"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="Offset" 
        command="SetOffset" 
        number_of_elements="1"
        animateable="1"
        default_values="0" > 
       <IntRangeDomain name="range" min="0"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="RandomMode" 
        command="SetRandomMode" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="GenerateVertices" 
        command="SetGenerateVertices" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
   <!-- End MaskPoints -->
   </SourceProxy>

   <SourceProxy name="Median" class="vtkImageMedian3D">
    <Documentation>
The Median filter operates on uniform rectilinear (image or volume) data and produces uniform rectilinear output. It replaces the scalar value at each pixel / voxel with the median scalar value in the specified surrounding neighborhood (Kernel Size). From the Input menu, the user can select the data set on which to perform this calculation. The Scalar menu determines which scalar array will be used to determine the median. The Kernel Size entry boxes specify the number of pixels / voxels in each dimension to use in computing the median to assign to each pixel / voxel. If the kernel size in a particular dimension is 1, then the median will not be computed in that direction. Since the median operation removes outliers, this filter is useful for removing high-intensity, low-probability noise (shot noise).
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkImageData"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point" 
                            number_of_components="1"/>
     </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2">
           <ArrayListDomain name="array_list" attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
     </StringVectorProperty>

     <IntVectorProperty 
        name="KernelSize" 
        command="SetKernelSize" 
        number_of_elements="3"
        default_values="1 1 1" > 
       <IntRangeDomain name="range"/>
     </IntVectorProperty>
   <!-- End Median -->
   </SourceProxy>

   <SourceProxy name="MeshQuality" class="vtkMeshQuality">
    <Documentation
       long_help="This filter creates a new cell array containing a geometric measure of each cell's fitness. Different quality measures can be chosen for different cell shapes."
       short_help="Evaluate geometric mesh quality.">
This filter creates a new cell array containing a geometric measure of each cell's fitness. Different quality measures can be chosen for different cell shapes. Supported shapes include triangles, quadrilaterals, tetrahedra, and hexahedra. For other shapes, a value of 0 is assigned.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
     </InputProperty>
     <IntVectorProperty
        name="TriangleQualityMeasure"
        command="SetTriangleQualityMeasure"
        number_of_elements="1"
        default_values="2">
       <EnumerationDomain name="enum">
         <Entry value="0" text="Edge Ratio"/>
         <Entry value="1" text="Aspect Ratio"/>
         <Entry value="2" text="Radius Ratio"/>
         <Entry value="3" text="Aspect Frobenius"/>
         <Entry value="6" text="Minimum Angle"/>
         <Entry value="8" text="Maximum Angle"/>
         <Entry value="9" text="Condition"/>
         <Entry value="10" text="Scaled Jacobian"/>
         <Entry value="12" text="Relative Size Squared"/>
         <Entry value="13" text="Shape"/>
         <Entry value="14" text="Shape and Size"/>
         <Entry value="15" text="Distortion"/>
       </EnumerationDomain>
     </IntVectorProperty>
     <IntVectorProperty
        name="QuadQualityMeasure"
        command="SetQuadQualityMeasure"
        number_of_elements="1"
        default_values="0">
       <EnumerationDomain name="enum">
         <Entry value="0" text="Edge Ratio"/>
         <Entry value="1" text="Aspect Ratio"/>
         <Entry value="2" text="Radius Ratio"/>
         <Entry value="4" text="Average Aspect Frobenius"/>
         <Entry value="5" text="Maximal Aspect Frobenius"/>
         <Entry value="6" text="Maximum Edge Ratio"/>
         <Entry value="17" text="Skew"/>
         <Entry value="18" text="Taper"/>
         <Entry value="26" text="Warpage"/>
         <Entry value="28" text="Area"/>
         <Entry value="20" text="Stretch"/>
         <Entry value="6" text="Minimum Angle"/>
         <Entry value="8" text="Maximum Angle"/>
         <Entry value="23" text="Oddy"/>
         <Entry value="9" text="Condition"/>
         <Entry value="25" text="Jacobian"/>
         <Entry value="10" text="Scaled Jacobian"/>
         <Entry value="11" text="Shear"/>
         <Entry value="12" text="Relative Size Squared"/>
         <Entry value="13" text="Shape"/>
         <Entry value="14" text="Shape and Size"/>
         <Entry value="24" text="Shear and Size"/>
         <Entry value="15" text="Distortion"/>
       </EnumerationDomain>
     </IntVectorProperty>
     <IntVectorProperty
        name="TetQualityMeasure"
        command="SetTetQualityMeasure"
        number_of_elements="1"
        default_values="2">
       <EnumerationDomain name="enum">
         <Entry value="0" text="Edge Ratio"/>
         <Entry value="1" text="Aspect Ratio"/>
         <Entry value="2" text="Radius Ratio"/>
         <Entry value="3" text="Aspect Frobenius"/>
         <Entry value="6" text="Minimal Dihedral Angle"/>
         <Entry value="7" text="Collapse Ratio"/>
         <Entry value="29" text="Aspect Beta"/>
         <Entry value="27" text="Aspect Gamma"/>
         <Entry value="19" text="Volume"/>
         <Entry value="9" text="Condition"/>
         <Entry value="25" text="Jacobian"/>
         <Entry value="10" text="Scaled Jacobian"/>
         <Entry value="12" text="Relative Size Squared"/>
         <Entry value="13" text="Shape"/>
         <Entry value="14" text="Shape and Size"/>
         <Entry value="15" text="Distortion"/>
       </EnumerationDomain>
     </IntVectorProperty>
     <IntVectorProperty
        name="HexQualityMeasure"
        command="SetHexQualityMeasure"
        number_of_elements="1"
        default_values="5">
       <EnumerationDomain name="enum">
         <Entry value="0" text="Edge Ratio"/>
         <Entry value="4" text="Average Aspect Frobenius"/>
         <Entry value="5" text="Maximal Aspect Frobenius"/>
         <Entry value="6" text="Maximum Edge Ratio"/>
         <Entry value="17" text="Skew"/>
         <Entry value="18" text="Taper"/>
         <Entry value="19" text="Volume"/>
         <Entry value="20" text="Stretch"/>
         <Entry value="21" text="Diagonal"/> 
         <Entry value="22" text="Dimension"/>
         <Entry value="23" text="Oddy"/>
         <Entry value="9" text="Condition"/>
         <Entry value="25" text="Jacobian"/>
         <Entry value="10" text="Scaled Jacobian"/>
         <Entry value="11" text="Shear"/>
         <Entry value="12" text="Relative Size Squared"/>
         <Entry value="13" text="Shape"/>
         <Entry value="14" text="Shape and Size"/>
         <Entry value="24" text="Shear and Size"/>
         <Entry value="15" text="Distortion"/>
       </EnumerationDomain>
     </IntVectorProperty>
   <!-- End MeshQuality -->
   </SourceProxy>

   <SourceProxy name="PolyDataNormals" class="vtkPPolyDataNormals">
    <Documentation
       long_help="This filter will produce surface normals used for smooth shading.  Spltting is used to avoid smoothing across feature edges."
       short_help="Produce surface point normals.">
The Normals generation filter generates surface normals at the points of the input polygonal data set to provide smooth shading of the data set. The resulting data set is also polygonal. The filter works by calculating a normal vector for each polygon in the data set and then averaging the normals at the shared points.
In creating surface normals, if the angle between two polygons at a shared edge is larger than the value of the Feature angle slider, then that edge is considered a feature edge. If Splitting is turned on, then the mesh will be split along feature edges, allowing points to be duplicated. Because the duplicated points are no longer shared between the polygons meeting at the feature edge, a normal at these points will be created per polygon rather than averaging the polygon normals to produce one normal at each point. This allows the feature edges to remain "sharp" after shading.
Generally the normals for a data set should either all point inward or all point outward. If the Consistency check is on, then this filter will reorder the points of cells that whose normal vectors are oriented the opposite direction from the rest of those in the data set. If the Flip normals option is checked, this filter will reverse the normal direction (and reorder the points) for all polygons in the data set. You might want to do this if your viewing position will be inside the data set instead of outside of it. Sometimes you may have more than two polygons sharing an edge (i.e., a non-manifold edge). When this is the case and the Consistency option is checked, then if the Non-manifold check is on, this filter will try to maintain consistent normals across non-manifold edge, but doing this can corrupt the ordering of polygons at these edges.
This filter computes the normals at the points in the data set. In the process of doing this it computes polygon normals too. If you want these normals to be passed to the output of this filter, turn on the Cell normals option.
If this filter is run in parallel, the resulting data set will have seams along the processor boundaries unless the Piece invariant check box is marked.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
     </InputProperty>

     <DoubleVectorProperty 
        name="FeatureAngle" 
        command="SetFeatureAngle" 
        number_of_elements="1"
        default_values="30" > 
       <DoubleRangeDomain name="range" min="0" max="180"/>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="Splitting" 
        command="SetSplitting" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="Consistency" 
        command="SetConsistency" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="FlipNormals" 
        command="SetFlipNormals" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="NonManifoldTraversal" 
        command="SetNonManifoldTraversal" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ComputeCellNormals" 
        command="SetComputeCellNormals" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="PieceInvariant" 
        command="SetPieceInvariant" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
   <!-- End  PolyDataNormals -->
   </SourceProxy>

   <SourceProxy name="OutlineFilter" class="vtkPOutlineFilter">
     <Documentation
        long_help="This filter generates a bounding box representation of the input."
        short_help="Generates a bounding box.">
The Outline filter generates an axis-aligned bounding box for the input data set. The Input menu specifies the data set for which to create a bounding box. This filter operates on any type of data set and produces polygonal output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
      </InputProperty>
      <Hints>
        <Visibility replace_input="0" />
      </Hints>
   <!-- End  OutlineFilter -->
   </SourceProxy>

   <SourceProxy name="OutlineCornerFilter" class="vtkPOutlineCornerFilter">
    <Documentation
       long_help="This filter generates a bounding box representation of the input.  It only displays the corners of the bounding box."
       short_help="Generates corners of a bounding box.">
The Outline Corners filter generates the corners of a bounding box for the input data set (specified by the Input menu). The Corner factor slider specifies the relative length of the corners along the corresponding edges. This filter produces polygonal output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
     </InputProperty>

     <DoubleVectorProperty
        name="CornerFactor"
        command="SetCornerFactor"
        number_of_elements="1"
        default_values="0.2" >
       <DoubleRangeDomain name="range" min="0.001" max="0.5" />
     </DoubleVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End  OutlineCornerFilter -->
   </SourceProxy>

   <SourceProxy name="OctreeDepthScalars" class="vtkHyperOctreeDepth">
     <Documentation
        long_help="This filter adds a scalar to each leaf of the octree that represents the leaf's depth within the tree."
        short_help="Computes cell depths within the octree.">
The vtkHyperOctreeDepth filter adds a scalar to each leaf of the octree that represents the leaf's depth within the tree.
     </Documentation>
     <InputProperty
        name="Input"
        command="AddInputConnection"
        clean_command="RemoveAllInputs">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkHyperOctree"/>
           </DataTypeDomain>
      </InputProperty>
   <!-- End  OctreeDepthScalars-->
   </SourceProxy>

   <SourceProxy name="OctreeDepthLimit" class="vtkHyperOctreeLimiter">
     <Documentation
        long_help="This filter takes in a octree and produces a new octree which is no deeper than the maximum specified depth level."
        short_help="Reduce an octree's resolution.">
The vtkHyperOctreeLimiter takes in a octree and produces a new octree in which is nowhere deeper than the maximum specified depth level. The attribute data of pruned leaf cells is integrated in to their ancestors at the cut level.
     </Documentation>
     <InputProperty
        name="Input"
        command="AddInputConnection"
        clean_command="RemoveAllInputs">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkHyperOctree"/>
           </DataTypeDomain>
      </InputProperty>

     <IntVectorProperty 
        name="MaximumLevel" 
        command="SetMaximumLevel" 
        number_of_elements="1"
        default_values="4" > 
       <IntRangeDomain name="range" min="3" max="255"/>
     </IntVectorProperty>
   <!-- End  OctreeDepthLimit-->
   </SourceProxy>

   <SourceProxy name="ProcessIdScalars" class="vtkProcessIdScalars">
     <Documentation
        long_help="This filter uses colors to show how data is partitioned across processes."
        short_help="Generate point scalars from process id.">
The Process Id Scalars filter assigns a unique scalar value to each piece of the input according to which processor it resides on. If the Random option is selected, the unique value per piece will be chosen at random; otherwise it will match the process id. This filter operates on any type of data when ParaView is run in parallel. It is useful for determining whether your data is load-balanced across the processors being used. The output data set type is the same as that of the input.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
     </InputProperty>

     <IntVectorProperty 
        name="RandomMode" 
        command="SetRandomMode" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
   <!-- End PieceScalars -->
   </SourceProxy>

   <SourceProxy name="PointDataToCellData" class="vtkPointDataToCellData">
     <Documentation
        long_help="Create cell attributes by averaging point attributes."
        short_help="Convert point data to cell data.">
The Point Data to Cell Data filter averages the values of the point attributes of the points of a cell to compute cell attributes. The Input menu allows the user to select the data set to which this filter will be applied. If the Pass point data option is checked, then the input point attributes will also be copied to the point attributes of the output; otherwise the output will only have cell attributes. The Point Data to Cell Data filter operates on any type of data set, and the output data set is of the same type as the input.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"/>
           <FixedTypeDomain name="fixed_type"/>
      </InputProperty>

     <IntVectorProperty 
        name="PassPointData" 
        command="SetPassPointData" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
   <!-- End CellDataToPointData -->
   </SourceProxy>

   <SourceProxy name="QuadricClustering" class="vtkQuadricClustering">
    <Documentation
       long_help="This filter is the same filter used to generate level of detail for ParaView.  It uses a structured grid of bins and merges all points contained in each bin."
       short_help="Simplify polygonal models.">
The Quadric Clustering filter produces a reduced-resolution polygonal approximation of the input polygonal data set. This filter is the one used by ParaView for computing LODs. It uses spatial binning to reduce the number of points in the data set; points that lie within the same spatial bin are collapsed into one representative point. The Divisions entries specify the number of bins along the X, Y, and Z axes of the data set. If Use input points is on, the representative point for each bin is selected from one of the input points that lies in that bin; the input point that produces the least error is chosen. Without this option selected, the location of the representative point is calculated to produce the least error possible for that bin, but the point will most likely not be one of the input points.
To better align pieces of the data set assigned to different processors, select Use feature edges and Use feature points. Use feature edges adjusts the representative points that contain boundary edges (along processor divisions), and Use feature points further influences the position of the feature points along the boundaries.
The Copy cell data toggle controls whether cell-centered data from the input should be copied to the output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
     </InputProperty>

     <IntVectorProperty 
        name="NumberOfDivisions" 
        command="SetNumberOfDivisions" 
        number_of_elements="3"
        default_values="50 50 50" > 
       <IntRangeDomain name="range"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="UseInputPoints" 
        command="SetUseInputPoints" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="UseFeatureEdges" 
        command="SetUseFeatureEdges" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="UseFeaturePoints" 
        command="SetUseFeaturePoints" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="CopyCellData" 
        command="SetCopyCellData" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty
        name="UseInternalTriangles"
        command="SetUseInternalTriangles"
        number_of_elements="1"
        default_values="0">
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
   <!-- End QuadricClustering -->
   </SourceProxy>

   <SourceProxy name="BrownianPoints" class="vtkBrownianPoints">
    <Documentation
       long_help="This filter creates a new 3 component point data array and sets it as the default vectors.  It uses a random number generator to create values."
       short_help="Create a new random vector array.">
The Random Vectors filter generates a point-centered array of random vectors. It uses a random number generator to determine the components of the vectors. The Min. speed and Max. speed values determine the range of the vector magnitudes. This filter operates on any type of data set, and the output data set will be of the same type as the input.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
     </InputProperty>

     <DoubleVectorProperty 
        name="MinimumSpeed" 
        command="SetMinimumSpeed" 
        number_of_elements="1"
        default_values="0" > 
       <DoubleRangeDomain name="range" min="0" />
     </DoubleVectorProperty>

     <DoubleVectorProperty 
        name="MaximumSpeed" 
        command="SetMaximumSpeed" 
        number_of_elements="1"
        default_values="1" > 
       <DoubleRangeDomain name="range" min="0"/>
     </DoubleVectorProperty>
   <!-- End BrownianPoints -->
   </SourceProxy>

   <SourceProxy name="ReflectionFilter" class="vtkReflectionFilter">
    <Documentation
       long_help="This filter takes the union of the input and its reflection over an axis-aligned plane."
       short_help="Reflect input over an axis aligned plane.">
The Reflection filter reflects the input data set across the specified plane. If the Copy Input check box is marked, the output is the union of the input data set and its reflection. Otherwise the output will contain only the reflection of the input data. If the value chosen from the Plane menu is X, Y, or Z, the value of the Center entry determines where the plane is placed along the specified axis. The other six entries, X Min, X Max, etc., place the reflection plane at the specified face of the bounding box of the input data set. This filter operates on any type of data set and produces an unstructured grid output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
     </InputProperty>

     <IntVectorProperty 
        name="Plane" 
        command="SetPlane" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="X Min"/>
         <Entry value="1" text="Y Min"/>
         <Entry value="2" text="Z Min"/>
         <Entry value="3" text="X Max"/>
         <Entry value="4" text="Y Max"/>
         <Entry value="5" text="Z Max"/>
         <Entry value="6" text="X"/>
         <Entry value="7" text="Y"/>
         <Entry value="8" text="Z"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="Center"
        command="SetCenter"
        number_of_elements="1"
        animateable="1"
        default_values="0.0" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="CopyInput"
        command="SetCopyInput"
        number_of_elements="1"
        default_values="1">
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
   <!-- End ReflectionFilter -->
   </SourceProxy>

   <SourceProxy name="RibbonFilter" class="vtkRibbonFilter">
    <Documentation
       long_help="This filter generates ribbon surface from lines.  It is useful for displaying streamlines."
       short_help="Create ribbon surfaces from lines.">
The Ribbon filter creates ribbons from the lines in the input data set. This filter is useful for visualizing streamlines. Both the input and output of this filter are polygonal data. The input data set must also have at least one point-centered vector array.
The vectors and scalars for use in this filter can be selected from the Vectors and Scalars menus respectively. If the Vary width option is on, the width of the ribbons will be scaled according to the selected scalars. If Use default normal is off, the selected vector array will be used as the normals of the ribbons. If Use default normal is on, the normal for the ribbons is specified by the values in the Default normal entry boxes.
The Width entry box specifies half the width of the ribbons. If Vary width is on, then the Width value specified is half the minimum width of the ribbons. The Angle value determines the orientation of the ribbons; it specifies the offset angle (in degrees) of the ribbon from the normal line.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array1" attribute_type="point"
                            number_of_components="3" optional="1"/>
          <InputArrayDomain name="input_array2" attribute_type="point"
                            number_of_components="1" optional="1"/>
     </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2">
           <ArrayListDomain name="array_list" attribute_type="Scalars"
                            input_domain_name="input_array2">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
     </StringVectorProperty> 

     <StringVectorProperty 
        name="SelectInputVectors" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2">
           <ArrayListDomain name="array_list" attribute_type="Vectors"
                            input_domain_name="input_array1">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
     </StringVectorProperty>

     <DoubleVectorProperty
        name="Width"
        command="SetWidth"
        number_of_elements="1"
        default_values="1" >
       <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="0.01">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="Angle"
        command="SetAngle"
        number_of_elements="1"
        default_values="0" >
       <DoubleRangeDomain name="range" min="0" max="360" />
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="UseDefaultNormal" 
        command="SetUseDefaultNormal" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="DefaultNormal"
        command="SetDefaultNormal"
        number_of_elements="3"
        default_values="0 0 1" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="VaryWidth" 
        command="SetVaryWidth" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
   <!-- End RibbonFilter -->
   </SourceProxy>

   <SourceProxy name="RotationalExtrusionFilter" 
                class="vtkRotationalExtrusionFilter">
    <Documentation
       long_help="This filter generates a swept surface while translates the input along a circular path."
       short_help="Generates a swept surface using a rotational path.">
The Rotational Extrusion filter forms a surface by rotating the input about the Z axis. This filter is intended to operate on 2D polygonal data. The Input menu allows the user to select the data set to which this filter will be applied. The value of the Resolution thumb wheel specifies the number of steps taken in rotating from 0 to the value specified in the Angle entry box. The Translation entry box determines the distance along the Z axis to be covered as the data set is rotated. Specifying a non-zero Translation value allows you to create a corkscrew or spring effect. The Delta radius entry box controls how much the radius of the rotation increases as the new data set is swept out.
The Capping check box controls whether to close the open ends of the swept surface. Capping works by placing a copy of the input data set on either end of the swept surface, so it behaves properly if the input is a 2D surface composed of filled polygons. If the input data set is a closed solid (e.g., a sphere), then either two copies of the data set will be drawn or no surface will be drawn. No surface is drawn if either capping is on or if the two surfaces would occupy exactly the same 3D space (e.g., Angle is a multiple of 360, and Translation and Delta radius are 0).
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
     </InputProperty>

     <IntVectorProperty 
        name="Resolution" 
        command="SetResolution" 
        number_of_elements="1"
        default_values="12" > 
       <IntRangeDomain name="range" min="1"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="Capping" 
        command="SetCapping" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="Angle"
        command="SetAngle"
        number_of_elements="1"
        animateable="1"
        default_values="360" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="Translation"
        command="SetTranslation"
        number_of_elements="1"
        animateable="1"
        default_values="0" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="DeltaRadius"
        command="SetDeltaRadius"
        number_of_elements="1"
        default_values="0" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>
   <!-- End RotationalExtrusionFilter -->
   </SourceProxy>

   <SourceProxy name="ShrinkFilter" class="vtkShrinkFilter">
     <Documentation
        long_help="This filter shrinks each input cell so they pull away from their neighbors."
        short_help="Shrink each input cell.">
The Shrink filter causes the individual cells of a data set to break apart from each other by moving each cell's points toward the centroid of the cell. (The centroid of a cell is the average position of its points.) The Shrink factor scale determines how far the points will move. A value of 0 positions the points at the centroid of the cell; a value of 1 leaves them at their original positions. This filter operates on any type of data set and produces unstructured grid output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
      </InputProperty>

      <DoubleVectorProperty
         name="ShrinkFactor"
         command="SetShrinkFactor"
         number_of_elements="1"
         animateable="1"
         default_values="0.5" >
        <DoubleRangeDomain name="range" min="0" max="1" />
      </DoubleVectorProperty>
   <!-- End ShrinkFilter -->
   </SourceProxy>

   <SourceProxy name="SmoothPolyDataFilter" class="vtkSmoothPolyDataFilter">
    <Documentation
       long_help="This filter smooths a polygonal surface by iteratively moving points toward their neighbors."
       short_help="Smooth a polygonal surface without adding more points.">
The Smooth filter operates on a polygonal data set by iteratively adjusting the position of the points using Laplacian smoothing. (Because this filter only adjusts point positions, the output data set is also polygonal.) This results in better-shaped cells and more evenly distributed points. The Num. iterations thumb wheel specifies the maximum number of smoothing iterations to perform. The Convergence slider limits the maximum motion of any point. It is expressed as a fraction of the length of the diagonal of the bounding box of the data set. If the maximum point motion during a smoothing iteration is less than the Convergence value, the smoothing operation terminates.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
     </InputProperty>

     <IntVectorProperty 
        name="NumberOfIterations" 
        command="SetNumberOfIterations" 
        number_of_elements="1"
        animateable="1"
        default_values="20" > 
       <IntRangeDomain name="range" min="0"/>
     </IntVectorProperty>

      <DoubleVectorProperty
         name="Convergence"
         command="SetConvergence"
         number_of_elements="1"
         default_values="0.0" >
        <DoubleRangeDomain name="range" min="0" max="1" />
      </DoubleVectorProperty>
   <!-- End SmoothPolyDataFilter -->
   </SourceProxy>

   <SourceProxy name="Stripper" class="vtkStripper">
    <Documentation
       long_help="This filter uses a greedy algorithm to convert triangles into triangle strips"
       short_help="Convert triangles into triangle strips.">
The Triangle Strips filter converts triangles into triangle strips and lines into polylines. The Max. length slider determines the maximum number of triangles or lines to merge into a strip. This filter operates on polygonal data sets and produces polygonal output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
     </InputProperty>

     <IntVectorProperty 
        name="MaximumLength" 
        command="SetMaximumLength" 
        number_of_elements="1"
        default_values="1000" > 
       <IntRangeDomain name="range" min="4" max="100000"/>
     </IntVectorProperty>
   <!-- End Stripper -->
   </SourceProxy>

   <SourceProxy name="Subdivide" class="vtkLinearSubdivisionFilter">
    <Documentation
       long_help="This filter iteratively divide triangles into four smaller triangles.  New points are placed linearly so the output surface matches the input surface."
       short_help="Creates a surface with more triangles than the input.">
The Subdivide filter iteratively divides each triangle in the data set into 4 new triangles. Three new points are added per triangle -- one at the midpoint of each edge. The image below shows a triangle with the new points inserted and the appropriate edges added to form the four new triangles. The Num. divisions slider determines the number of subdivision passes the filter will take through the data. This filter operates only on polygonal data containing triangles, so run your polygonal data through the Triangulate filter first if it is not composed of triangles. The output of this filter is also polygonal.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
     </InputProperty>

     <IntVectorProperty 
        name="NumberOfSubdivisions" 
        command="SetNumberOfSubdivisions" 
        number_of_elements="1"
        default_values="1" > 
       <IntRangeDomain name="range" min="1" max="4"/>
     </IntVectorProperty>
   <!-- End Subdivide -->
   </SourceProxy>

   <SourceProxy name="TessellatorFilter" class="vtkTessellatorFilter">
     <Documentation
        long_help="Tessellate nonlinear curves, surfaces, and volumes with lines, triangles, and tetrahedra."
        short_help="Polygonize a mesh.">
The Tessellate filter tessellates cells with nonlinear geometry and/or scalar fields into a simplicial complex with linearly interpolated field values that more closely approximate the original field. This is useful for the quadratic cells supported by VTK. There are several settings that affect the tessellation.
The Output Dimension specifies whether nonlinear cells should have their volumes, surfaces, or edges tessellated. When the Output Dimension is 3, 3-D cells produce tetrahedra, 2-D cells produce triangles, and 1-D cells produce line segments. When the Output Dimension is 2, 3-D cells will have their boundaries tessellated with triangles. When the Output Dimension is 1, then all cells except points produce line segments.
The Max Chord Error setting is the maximum allowed distance between the midpoint of any output edge and the original nonlinear geometry.
The Max Field Error setting is a per-field error, also sampled at midpoints, but comparing the linear and nonlinear field values.
The Max Num Of Subdivisions setting specifies the maximum number of times an edge may be subdivided. Increasing this number allows further refinement but can drastically increase the computational and storage requirements, especially when the Output Dimension is 3.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
             <DataType value="vtkDataSet"/>
             <DataType value="vtkUnstructuredGrid"/>
           </DataTypeDomain>
     </InputProperty>

     <IntVectorProperty
        name="OutputDimension"
        command="SetOutputDimension"
        number_of_elements="1"
        default_values="3">
       <IntRangeDomain name="range" min="1" max="3"/>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="ChordError"
        command="SetChordError"
        number_of_elements="1"
        default_values="1e-3">
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="FieldError2"
        command="SetFieldCriterion"
        repeat_command="1"
        number_of_elements_per_command="1"
        use_index="1"/>

     <IntVectorProperty
        name="MaximumNumberOfSubdivisions"
        command="SetMaximumNumberOfSubdivisions"
        number_of_elements="1"
        default_values="3">
       <IntRangeDomain name="range" min="0" max="8"/>
     </IntVectorProperty>

     <Property
        name="ResetFieldCriteria"
        command="ResetFieldCriteria"
        immediate_update="1">
     </Property>
   <!-- End TessellatorFilter -->
   </SourceProxy>

   <SourceProxy name="DataSetTriangleFilter" class="vtkDataSetTriangleFilter">
     <Documentation
        long_help="This filter converts 3-d cells to tetrahedrons and polygons to triangles.  The output is always of type unstructured grid."
        short_help="Convert to tetrahedrons and triangles.">
The Tetrahedralize filter converts the 3D cells of any type of data set to tetrahedrons and the 2D ones to triangles. This filter always produces unstructured grid output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
      </InputProperty>
   <!-- End DataSetTriangleFilter -->
   </SourceProxy>

   <SourceProxy name="TransformFilter" class="vtkTransformFilter">
    <Documentation
       long_help="This filter applies transformation to the polygons."
       short_help="Transform polygonal data.">
The Transform filter allows you to specify the position, size, and orientation of polygonal, unstructured grid, and curvilinear data sets. You can interactively perform these affine transformations on the data by using the box widget, and the parameters can also be controlled manually. See section 7.4 for the details of using the box widget and manually setting its parameters. The output of this filter will have the same data set type as the input.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPointSet"/>
          </DataTypeDomain>
     </InputProperty>

     <ProxyProperty name="Transform" command="SetTransform">
           <ProxyGroupDomain name="groups">
              <Group name="transforms"/>
           </ProxyGroupDomain>
     </ProxyProperty>
   <!-- End TransformFilter -->
   </SourceProxy>

   <SourceProxy name="TriangleFilter" class="vtkTriangleFilter">
     <Documentation
        long_help="This filter converts polygons and triangle strips to basic triangles."
        short_help="Convert polygonal data to triangles.">
The Triangulate filter decomposes polygonal data into only triangles, points, and lines. It separates triangle strips and polylines into individual triangles and lines, respectively. The output is polygonal data. Some filters that take polygonal data as input require that the data be composed of triangles rather than other polygons, so passing your data through this filter first is useful in such situations. You should use this filter in these cases rather than the Tetrahedralize filter because they produce different output data set types. The filters referenced require polygonal input, and the Tetrahedralize filter produces unstructured grid output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
      </InputProperty>
   <!-- End TriangleFilter -->
   </SourceProxy>

   <SourceProxy name="TubeFilter" class="vtkTubeFilter">
    <Documentation
       long_help="Convert lines into tubes.  Normals are used to avoid cracks between tube segments."
       short_help="Convert lines into tubes.">
The Tube filter creates tubes around the lines in the input polygonal data set. The output is also polygonal. The Num. sides value determines the number of faces around the circumference of the tube. The Capping toggle specifies whether to close the end of the tube with a polygon. The Radius entry determines the radius of the tube (or the minimum radius if you are varying the radius). From the Vary radius menu, you can select whether the radius of the tube should vary, and if so, whether it should be by scalar or by vector. If the radius is varied by scalar, the tube radius is based on the point-based scalar values. If it is varied by vector, the vector magnitude is used. If you are varying the radius, the value in the Radius factor entry determines the maximum radius by specifying a multiplier of the Radius value.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
     </InputProperty>

     <IntVectorProperty 
        name="NumberOfSides" 
        command="SetNumberOfSides" 
        number_of_elements="1"
        animateable="1"
        default_values="6" > 
       <IntRangeDomain name="range" min="3"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="Capping" 
        command="SetCapping" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

      <DoubleVectorProperty
         name="Radius"
         command="SetRadius"
         number_of_elements="1"
         default_values="1.0" >
        <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="0.01">
          <RequiredProperties>
             <Property name="Input" function="Input"/>
          </RequiredProperties>
`       </BoundsDomain>
      </DoubleVectorProperty>

     <IntVectorProperty 
        name="VaryRadius" 
        command="SetVaryRadius" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Off"/>
         <Entry value="1" text="By Scalar"/>
         <Entry value="2" text="By Vector"/>
       </EnumerationDomain>
     </IntVectorProperty>

      <DoubleVectorProperty
         name="RadiusFactor"
         command="SetRadiusFactor"
         number_of_elements="1"
         default_values="10" >
        <DoubleRangeDomain name="range"/>
      </DoubleVectorProperty>
   <!-- End TubeFilter -->
   </SourceProxy>

   <SourceProxy name="WarpScalar" class="vtkWarpScalar">
     <Documentation
        long_help="This filter moves point coordinates along a vector scaled by a point attribute.  It can be used to produce carpet plots."
        short_help="Warp point scalars into a spatial elevation plot.">
The Warp (scalar) filter translates the points of the input data set along a vector by a distance determined by the specified scalars (selected from the Scalars menu). The Scale factor entry allows you to rescale the scalar values used in warping the data.
The Normal entries specify the direction in which to warp the geometry if the Use normal option is checked. If Use normal and X-Y plane are off, the data set will be warped along its normals array. (If no normals array exists, the Normal value will be used.) If X-Y plane is on, the Z-values in the data set are considered to be scalars, and warping is done along the Z axis. This is useful for creating carpet plots. Any scalars in the data set are copied to the output, so the data can be colored by them.
This filter operates on polygonal, curvilinear, and unstructured grid data sets containing single-component scalar arrays. Because it only changes the positions of the points, the output data set type is the same as that of the input.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPointSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"
                             number_of_components="1"/>
     </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
          number_of_elements="5"
          element_types="0 0 0 0 2">
           <ArrayListDomain name="array_list" attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
     </StringVectorProperty>

     <DoubleVectorProperty
        name="ScaleFactor"
        command="SetScaleFactor"
        number_of_elements="1"
        animateable="1"
        default_values="1.0" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="Normal"
        command="SetNormal"
        number_of_elements="3"
        default_values="0 0 1" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="UseNormal" 
        command="SetUseNormal" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="XYPlane" 
        command="SetXYPlane" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
   <!-- End WarpScalar -->
   </SourceProxy>

   <SourceProxy name="WarpVector" class="vtkWarpVector">
     <Documentation
        long_help="This filter displaces point coordinates along a vector attribute.  It is useful for showing mechanical deformation."
        short_help="Warp (displace) the geometry with a given vector field.">
The Warp (vector) filter translates the points of the input data set using a specified vector array. The vector array chosen specifies a vector per point in the input. Each point is translated along its vector by the value in the Scale factor entry box. This filter operates on polygonal, curvilinear, and unstructured grid data sets. Because this filter only changes the positions of the points, the output data set type is the same as that of the input. This filter is available on the Toolbar.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPointSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"
                             number_of_components="3"/>
      </InputProperty>

      <StringVectorProperty 
         name="SelectInputVectors" 
         command="SetInputArrayToProcess"
         number_of_elements="5"
         element_types="0 0 0 0 2">
            <ArrayListDomain name="array_list" attribute_type="Vectors">
              <RequiredProperties>
                 <Property name="Input" function="Input"/>
              </RequiredProperties>
            </ArrayListDomain>
      </StringVectorProperty> 

      <DoubleVectorProperty
         name="ScaleFactor"
         command="SetScaleFactor"
         number_of_elements="1"
         default_values="1.0" >
        <DoubleRangeDomain name="range"/>
      </DoubleVectorProperty>
   <!-- End WarpVector -->
   </SourceProxy>

   <SourceProxy name="AnimateWarp" class="vtkWarpVector">
     <Documentation
        long_help="This filter displaces point coordinates along a vector attribute.  It is useful for showing mechanical deformation. This class also simplifies the animation process."
        short_help="Warp (displace) the geometry with a given vector field.">
The Warp (vector) filter translates the points of the input data set using a specified vector array. The vector array chosen specifies a vector per point in the input. Each point is translated along its vector by the value in the Scale factor entry box. This filter operates on polygonal, curvilinear, and unstructured grid data sets. Because this filter only changes the positions of the points, the output data set type is the same as that of the input. This filter is available on the Toolbar.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPointSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"
                             number_of_components="3"/>
      </InputProperty>

      <StringVectorProperty 
         name="SelectInputVectors" 
         command="SetInputArrayToProcess"
         number_of_elements="5"
         element_types="0 0 0 0 2">
            <ArrayListDomain name="array_list" attribute_type="Vectors">
              <RequiredProperties>
                 <Property name="Input" function="Input"/>
              </RequiredProperties>
            </ArrayListDomain>
      </StringVectorProperty> 

      <DoubleVectorProperty
         name="ScaleFactor"
         command="SetScaleFactor"
         number_of_elements="1"
         default_values="1.0" >
        <DoubleRangeDomain name="range"/>
      </DoubleVectorProperty>
   <!-- End AnimateWarp -->
   </SourceProxy>

   <SourceProxy name="Cut" class="vtkCutter">
    <Documentation
       long_help="This filter cuts a data set with a plane or sphere.  Cutting is similar to a contour.  It creates surfaces from volumes and lines from surfaces."
       short_help="Cut datasets with planes or spheres.">
The Cut filter extracts the portion of the input data set that lies along the specified plane or sphere. From the Cut Function menu, you can select whether cutting will be performed with a plane or a sphere. The appropriate 3D widget (plane widget or sphere widget) will be displayed. The parameters of the cut function can be specified interactively using the 3D widget or manually using the traditional user interface controls. Instructions for using these 3D widgets and their corresponding user interfaces are found in section 7.4.
By default, the cut lies on the specified plane or sphere. Using the Cut Offset Values portion of the interface, it is also possible to cut the data set at some offset from the original cut function. The Cut Offset Values are in the spatial units of the data set. To add a single offset, select the value from the New Value slider in the Add value portion of the interface and click the Add button, or press Enter. To instead add several evenly spaced offsets, use the controls in the Generate range of values section. Select the number of offsets to generate using the Number of Values slider. The Range slider controls the interval in which to generate the offsets. Once the number of values and range have been selected, click the Generate button. The new offsets will be added to the Offset Values list. To delete a value from the Cut Offset Values list, select the value and click the Delete button. (If no value is selected, the last value in the list will be removed.) Clicking the Delete All button removes all the values in the list.
The Cut filter takes any type of data set as input. Use the Input menu to choose a data set to cut. The output of this filter is polygonal data. This filter is available on the Toolbar.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
     </InputProperty>

     <ProxyProperty name="CutFunction" command="SetCutFunction">
           <ProxyGroupDomain name="groups">
              <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="Plane" />
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
           </ProxyListDomain>
     </ProxyProperty>

     <DoubleVectorProperty
        name="InputBounds" information_only="1">
       <BoundsDomain name="bounds">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="ContourValues"
        command="SetValue"
        repeat_command="1"
        set_number_command="SetNumberOfContours"
        number_of_elements_per_command="1"
        use_index="1"
        animateable="1">
          <BoundsDomain name="bounds" mode="magnitude">
            <RequiredProperties>
              <Property name="Input" function="Input"/>
            </RequiredProperties>
          </BoundsDomain>
     </DoubleVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End Cut -->
   </SourceProxy>

   <SourceProxy name="Clip" class="vtkPVClipDataSet">
    <Documentation
       long_help="Clip with an implicit plane, sphere or with scalars. Clipping does not reduce the dimensionality of the data set.  This output data type of this filter is always an unstructured grid."
       short_help="Clip with an implicit plane, sphere or with scalars.">
The Clip filter cuts away a portion of the input data set using a plane, a sphere, a box, or a scalar value. The menu in the Clip Function portion of the interface allows the user to select which implicit function to use or whether to clip using a scalar value. Making this selection loads the appropriate user interface. For the implicit functions, the appropriate 3D widget (plane, sphere, or box) is also displayed. The use of these 3D widgets, including their user interface components, is discussed in section 7.4.
If an implicit function is selected, the clip filter returns that portion of the input data set that lies inside the function. If Scalars is selected, then the user must specify a scalar array to clip according to. The clip filter will return the portions of the data set whose value in the selected Scalars array is larger than the Clip value. Regardless of the selection from the Clip Function menu, if the Inside Out option is checked, the opposite portions of the data set will be returned.
This filter operates on all types of data sets, and it returns unstructured grid data on output. This filter is available on the toolbar.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            optional="1"/>
     </InputProperty>

     <ProxyProperty name="ClipFunction" command="SetClipFunction">
           <ProxyGroupDomain name="groups">
               <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="Plane" />
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
           </ProxyListDomain>
     </ProxyProperty>

     <DoubleVectorProperty
        name="InputBounds"  information_only="1">
       <BoundsDomain name="bounds">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="InsideOut" 
        command="SetInsideOut" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2">
           <ArrayListDomain name="array_list" attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
     </StringVectorProperty> 

     <DoubleVectorProperty
        name="Value"
        command="SetValue"
        number_of_elements="1"
        default_values="0.0" >
          <ArrayRangeDomain name="scalar_range">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
               <Property name="SelectInputScalars" function="ArraySelection"/>
            </RequiredProperties>
          </ArrayRangeDomain>         
          <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>
   <!-- End Clip -->
   </SourceProxy>

   <SourceProxy name="Threshold" class="vtkThreshold">
    <Documentation
       long_help="This filter extracts cells that have point or cell scalars in the specified range."
       short_help="Extract cells that satisfy a threshold criterion.">
The Threshold filter extracts the portions of the input data set whose scalars lie within the specified range. This filter operates on either point-centered or cell-centered data. To select between these two options, select either Point Data or Cell Data from the Attribute Mode menu. Once the Attribute Mode has been selected, choose the scalar array from which to threshold the data from the Scalars menu. The Lower Threshold and Upper Threshold sliders determine the range of the scalars to retain in the output. The All Scalars check box only takes effect when the Attribute Mode is set to Point Data. If the All Scalars option is checked, then a cell will only be passed to the output if the scalar values of all of its points lie within the range indicated by the Lower Threshold and Upper Threshold sliders. If unchecked, then a cell will be added to the output if the specified scalar value for any of its points is within the chosen range. This filter operates on any type of data set and produces unstructured grid output. The Threshold filter is available on the Toolbar.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" number_of_components="1">
             <RequiredProperties>
                <Property name="SelectInputScalars" 
                          function="FieldDataSelection"/>
             </RequiredProperties>
          </InputArrayDomain>
     </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2">
           <ArrayListDomain name="array_list" 
                            attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <FieldDataDomain name="field_list">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </FieldDataDomain>
     </StringVectorProperty> 

     <DoubleVectorProperty 
        name="ThresholdBetween" 
        command="ThresholdBetween"
        number_of_elements="2"
        default_values="0 0">
          <ArrayRangeDomain name="range">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
               <Property name="SelectInputScalars" function="ArraySelection"/>
            </RequiredProperties>
          </ArrayRangeDomain>         
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="AllScalars" 
        command="SetAllScalars" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
   <!-- End Threshold -->
   </SourceProxy>

   <SourceProxy name="Contour" class="vtkContourFilter">
    <Documentation
       long_help="Generate isolines or isosurfaces using point scalars."
       short_help="Generate isolines or isosurfaces.">
The Contour filter computes isolines or isosurfaces using a selected point-centered scalar array. The available scalar arrays are listed in the Scalars menu. The scalar range of the selected array will be displayed.
The interface for adding contour values is very similar to the one for selecting cut offsets (in the Cut filter). To add a single contour value, select the value from the New Value slider in the Add value portion of the interface and click the Add button, or press Enter. To instead add several evenly spaced contours, use the controls in the Generate range of values section. Select the number of contour values to generate using the Number of Values slider. The Range slider controls the interval in which to generate the contour values. Once the number of values and range have been selected, click the Generate button. The new values will be added to the Contour Values list. To delete a value from the Contour Values list, select the value and click the Delete button. (If no value is selected, the last value in the list will be removed.) Clicking the Delete All button removes all the values in the list. If no values are in the Contour Values list when Accept is pressed, the current value of the New Value slider will be used.
In addition to selecting contour values, you can also select additional computations to perform. If any of Compute Normals, Compute Gradients, or Compute Scalars is selected, the appropriate computation will be performed, and a corresponding point-centered array will be added to the output.
The Contour filter operates on any type of data set, but the input is required to have at least one point-centered scalar (single-component) array. The output of this filter is polygonal. This filter is available on the Toolbar.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            number_of_components="1"/>
     </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        animateable="0"> 
          <ArrayListDomain name="array_list" attribute_type="Scalars">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
     </StringVectorProperty>

     <DoubleVectorProperty
        name="ContourValues"
        command="SetValue"
        set_number_command="SetNumberOfContours"
        number_of_elements="0"
        repeat_command="1"
        number_of_elements_per_command="1"
        use_index="1"
        animateable="1">
          <ArrayRangeDomain name="scalar_range">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
               <Property name="SelectInputScalars" function="ArraySelection"/>
            </RequiredProperties>
          </ArrayRangeDomain>         
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="ComputeNormals" 
        command="SetComputeNormals" 
        number_of_elements="1"
        default_values="1" 
        animateable="0"> 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ComputeGradients" 
        command="SetComputeGradients" 
        number_of_elements="1"
        default_values="0" 
        animateable="0"> 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ComputeScalars" 
        command="SetComputeScalars" 
        number_of_elements="1"
        default_values="0" 
        animateable="0"> 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End Contour -->
   </SourceProxy>


   <SourceProxy name="Glyph" class="vtkPVGlyphFilter">
    <Documentation
       long_help="This filter generates an arrow, cone, line, sphere, or 2D glyph at each point of the input data set.  The glyphs can be oriented and scaled by the input point attributes."
       short_help="Generate a glyph symbol at each point of the input data set.">
The Glyph filter generates a glyph (i.e., an arrow, cone, line, sphere, or 2D glyph) at each point in the input data set. The glyphs can be oriented and scaled by the input point-centered scalars and vectors.
From the Glyph menu, select which symbol should be drawn at each input point. The available choices are Arrow, Cone, Line, Sphere, and Glyph2D. To change the parameters of any of the glyphs (including which 2D glyph is drawn), choose the appropriate glyph from the Glyphs submenu of the Select menu. Change the desired parameter(s) and click Accept. To return to the Glyph interface, select this filter from the Selection / Navigation Window or from the Select menu.
The Orient / Scale section of the interface determines how the point-centered scalars and vectors contribute to the orientation and scale of the widgets. The Orient Mode menu determines whether the glyphs are drawn in their original orientation (Off) or in an orientation determined by a vector array (Vector). If the input does not contain point-centered vectors, the Vector option in the Orient Mode menu will not be available.
The Scale Mode menu determines how the scale of the glyphs will be calculated. The options are to scale by the selected scalar array (Scalar), to scale by the magnitudes of the selected vector array (Vector Magnitude), to scale by each component of the selected vector array (Vector Components), or to draw the all the glyphs at the same scale (Data Scaling Off). If the input contains no point-centered scalar arrays, the Scalar option will be disabled. If it has no point-centered vector arrays, the Vector Magnitude and Vector Components entries will be unavailable. The value of the Scale Factor entry box is a multiplier that contributes to the final size of the glyphs.
The Scalars and Vectors menus list the point-centered scalar (single-component) and vector (three-component) arrays in the input data set. These menus are enabled and disabled depending on the current Orient and Scale Mode selections.
The Glyph Parameters tab also contains controls for masking the input points before glyphing. (This is a simplified version of the Mask Points filter interface.) To enable point masking, turn on the Mask Points option. When this is selected, the Max. Number of Glyphs thumbwheel sets an upper limit on the number of glyphs to display. If the Random Masking option is on, the input points to glyph will be randomly selected; otherwise every second point will be glyphed, starting from the first point id.
The Glyph filter operates on any type of data set. Its output is polygonal. This filter is available on the Toolbar.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array1" attribute_type="point"
                            number_of_components="1" optional="1"/>
          <InputArrayDomain name="input_array2" attribute_type="point"
                            number_of_components="3" optional="1"/>
     </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"> 
          <ArrayListDomain name="array_list" attribute_type="Scalars" 
               input_domain_name="input_array1">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
     </StringVectorProperty>

     <StringVectorProperty 
        name="SelectInputVectors" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"> 
          <ArrayListDomain name="array_list" attribute_type="Vectors"
               input_domain_name="input_array2">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
     </StringVectorProperty>

     <InputProperty
        name="Source"
        command="SetSourceConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="glyph_sources" />
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="sources" name="SphereSource" />
              <Proxy group="sources" name="ConeSource" />
              <Proxy group="sources" name="CylinderSource" />
           </ProxyListDomain>
      </InputProperty>

     <IntVectorProperty 
        name="SetOrient" 
        command="SetOrient" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="SetScaleMode" 
        command="SetScaleMode" 
        number_of_elements="1"
        default_values="1" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="scalar"/>
         <Entry value="1" text="vector"/>
         <Entry value="2" text="vector_components"/>
         <Entry value="3" text="off"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="SetScaleFactor"
        command="SetScaleFactor"
        number_of_elements="1"
        default_values="1.0" >
       <DoubleRangeDomain name="range"/>
       <BoundsDomain name="bounds">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
       <ArrayRangeDomain name="scalar_range">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
            <Property name="SelectInputScalars" function="ArraySelection"/>
         </RequiredProperties>
       </ArrayRangeDomain>
       <ArrayRangeDomain name="vector_range">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
            <Property name="SelectInputVectors" function="ArraySelection"/>
         </RequiredProperties>
       </ArrayRangeDomain>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MaximumNumberOfPoints" 
        command="SetMaximumNumberOfPoints" 
        number_of_elements="1"
        default_values="5000" >
       <IntRangeDomain name="range" min="0"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="UseMaskPoints" 
        command="SetUseMaskPoints" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="RandomMode" 
        command="SetRandomMode" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
   <Hints>
     <!-- Visibility Element can be used to suggest the GUI about
          visibility of this filter (or its input) on creation.
          replace_input="0" implies that the input visibility is not
            changed on creation of this filter (defaults to "1")
       -->
     <Visibility replace_input="0" />
   </Hints>
   <!-- End Glyph -->
   </SourceProxy>

   <SourceProxy name="ExtractGrid" class="vtkPVExtractVOI">
    <Documentation
       long_help="Extract a subgrid from a structured grid with the option of setting subsample strides."
       short_help="Extract a subgrid or subsample.">
The Extract Grid filter returns a subgrid of a structured input data set (uniform rectilinear, curvilinear, or nonuniform rectilinear). The VOI section of the interface provides six sliders for specifying the extents of the desired output along each of the I, J, and K axes. The Sample Rate thumb wheels control whether to subsample the input grid in each dimension. Values greater than 1 result in subsampling. For example, if the Sample Rate along the I axis is 2, then every other input point will be passed to the output. If the Sample Rate in any dimension is greater than 1, then selecting the Include boundary option will pass the values on the boundary of the data set to the output even if the boundary extent is not an even multiple of the sample rate. The output data set type of this filter is the same as the input type. This filter is available on the Toolbar.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkImageData"/>
            <DataType value="vtkRectilinearGrid"/>
            <DataType value="vtkStructuredPoints"/>
            <DataType value="vtkStructuredGrid"/>
          </DataTypeDomain>
     </InputProperty>

     <IntVectorProperty 
        name="VOI" 
        command="SetVOI"
        number_of_elements="6"
        default_values="0 0 0 0 0 0">
       <ExtentDomain name="extent">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </ExtentDomain>
     </IntVectorProperty>

     <IntVectorProperty 
        name="SampleRateI" 
        command="SetSampleRateI"
        animateable="1"
        number_of_elements="1" default_values="1">
       <IntRangeDomain name="range" min="1"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="SampleRateJ" 
        command="SetSampleRateJ"
        animateable="1"
        number_of_elements="1" default_values="1">
       <IntRangeDomain name="range" min="1"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="SampleRateK" 
        animateable="1"
        command="SetSampleRateK"
        number_of_elements="1" default_values="1">
       <IntRangeDomain name="range" min="1"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="IncludeBoundary" 
        command="SetIncludeBoundary" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End ExtractGrid -->
   </SourceProxy>

   <SourceProxy name="DataAnalysis" class="vtkDataAnalysisFilter">
    <Documentation
       long_help="Sample point data at a point or along a line or by point id. Select cell at a point or by cell id. Data can be plotted on an XY plot."
       short_help="Pick a cell or point.">
    The Data Analysis filter provides the ability to query either cell or point data in a given data set. The data may be plotted as an plot. If the "Query Method" is "Point", the filter outputs the interpolated point data at the selected point. If the "Query Method" is "Cell", the filter outputs the cell data at the closest cell to the choosen point. If the "Query Method" is "Line", the filter interpolates the point data at the sample points on the line. If the "Query Method" is "Cell Id", the filter outputs the cell data for the cell with the given Id. If the "Query Method" is "Point Id", the filter outpus the point data for the point with the given Id. The data can be plotted on an XY plot. Additionally, if the input supports multiple timesteps, this filter can be used to plot the queried data over time.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
            <DataType value="vtkMultiGroupDataSet"/>
          </DataTypeDomain>
          <NumberOfPartsDomain name="multi_part" multiplicity="single"/>
          <NumberOfGroupsDomain name="multi_group" multiplicity="single"/>
     </InputProperty>

     <InputProperty
        name="Source"
        command="SetSourceConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
           </ProxyGroupDomain>
     </InputProperty>

     <IntVectorProperty name="Mode"
        command="SetMode"
        number_of_elements="1"
        default_values="1">
        <EnumerationDomain name="enum">
          <Entry text="Probe" value="0" />
          <Entry text="Pick" value="1" />
        </EnumerationDomain>
     </IntVectorProperty>
     <IntVectorProperty name="Id"
        command="SetId"
        number_of_elements="1"
        default_values="0">
        <IntRangeDomain name="range" min="0" />
     </IntVectorProperty>
     <IntVectorProperty name="UseIdToPick"
        command="SetUseIdToPick"
        number_of_elements="1"
        default_values="0">
        <BooleanDomain name="bool" />
     </IntVectorProperty>
     <IntVectorProperty name="PickCell"
        command="SetPickCell"
        number_of_elements="1"
        default_values="1">
        <BooleanDomain name="bool" />
     </IntVectorProperty>
     <DoubleVectorProperty
         name="WorldPoint"
         command="SetWorldPoint"
         number_of_elements="3"
         default_values="0 0 0" >
      </DoubleVectorProperty>
   <!-- End PickProbe -->
   </SourceProxy>

   <SourceProxy name="Probe" class="vtkPProbeFilter">
    <Documentation
       long_help="Sample data attributes at a point or along a line.  Probed lines will be displayed in a graph of the attributes."
       short_help="Sample data values at a point or along a line.">
The Probe filter samples the data set attributes of the current data set at a point or along a line. Selecting either Point or Line from the menu button in the Probe object portion of the interface displays the appropriate 3D widget and its associated user interface controls. See section 7.4 for more information about using 3D widgets.
If you are probing with a point, the values of the point-centered variables at the selected point will be listed on the Parameters tab for this filter. If you are probing with a line, the values of the point-centered variables along that line will be displayed in a 2D graph in the display area if Show XY-Plot is selected.
Probing with a point is different from using the Pick filter at a point because the Pick filter displays the values for the input point closest to the selected point. Instead the Probe filter uses interpolation to determine the value at the selected point, whether or not it lies at an input point.
The Probe filter operates on any type of data and produces polygonal output (a point or a line).
    </Documentation>
    <InputProperty
       name="Source"
       command="SetSourceConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
            <DataType value="vtkMultiGroupDataSet"/>
          </DataTypeDomain>
          <NumberOfPartsDomain name="multi_part" multiplicity="single"/>
          <NumberOfGroupsDomain name="multi_group" multiplicity="single"/>
          <InputArrayDomain name="input_array" attribute_type="point"/>
     </InputProperty>

     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
           </ProxyGroupDomain>
      </InputProperty>
   <!-- End Probe -->
   </SourceProxy>

   <SourceProxy name="Probe2" class="vtkPProbeFilter">
    <!-- This is same a Probe except that the Input is the data in which we are probing,
         while source is the dataset with which we are probing. The output is of the
         type of the source.
      -->
    <Documentation
       long_help="Sample data attributes at a point or along a line.  Probed lines will be displayed in a graph of the attributes."
       short_help="Sample data values at a point or along a line.">
The Probe filter samples the data set attributes of the current data set at a point or along a line. Selecting either Point or Line from the menu button in the Probe object portion of the interface displays the appropriate 3D widget and its associated user interface controls. See section 7.4 for more information about using 3D widgets.
If you are probing with a point, the values of the point-centered variables at the selected point will be listed on the Parameters tab for this filter. If you are probing with a line, the values of the point-centered variables along that line will be displayed in a 2D graph in the display area if Show XY-Plot is selected.
Probing with a point is different from using the Pick filter at a point because the Pick filter displays the values for the input point closest to the selected point. Instead the Probe filter uses interpolation to determine the value at the selected point, whether or not it lies at an input point.
The Probe filter operates on any type of data and produces polygonal output (a point or a line).
    </Documentation>
    <InputProperty
       name="Input"
       command="SetSourceConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
            <DataType value="vtkMultiGroupDataSet"/>
          </DataTypeDomain>
          <NumberOfPartsDomain name="multi_part" multiplicity="single"/>
          <NumberOfGroupsDomain name="multi_group" multiplicity="single"/>
          <InputArrayDomain name="input_array" attribute_type="point"/>
     </InputProperty>

     <InputProperty
        name="Source"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
             <Proxy group="sources" name="LineSource" />
             <Proxy group="sources" name="PointSource" />
           </ProxyListDomain>
      </InputProperty>
   <!-- End Probe2 -->
   </SourceProxy>

   <SourceProxy name="TemporalProbe" class="vtkTemporalProbeFilter">
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
    </InputProperty>
 
    <Property
       name="AnimateInit"
       command="AnimateInit"
       is_internal="1">
    </Property>

    <DoubleVectorProperty
       name="AnimateTick"
       command="AnimateTick"
       is_internal="1"
       number_of_elements="1"
       default_values="0.0" >
          <DoubleRangeDomain name="range" min="0" max="1" />
    </DoubleVectorProperty>

   <!-- End TemporalProbe -->
   </SourceProxy>

   <SourceProxy name="TemporalPick" class="vtkTemporalPickFilter">
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkUnstructuredGrid"/>
          </DataTypeDomain>
    </InputProperty>
 
    <Property
       name="AnimateInit"
       command="AnimateInit"
       is_internal="1">
    </Property>

    <DoubleVectorProperty
       name="AnimateTick"
       command="AnimateTick"
       is_internal="1"
       number_of_elements="1"
       default_values="0.0" >
          <DoubleRangeDomain name="range" min="0" max="1" />
    </DoubleVectorProperty>

    <IntVectorProperty 
       name="PointOrCell" 
       command="SetPointOrCell" 
       number_of_elements="1"
       default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="On"/>
         <Entry value="1" text="Off"/>
       </EnumerationDomain>
    </IntVectorProperty>

   <!-- End TemporalPick -->
   </SourceProxy>


   <SourceProxy name="StreamTracer" class="vtkDistributedStreamTracer">
    <Documentation
       long_help="Integrate streamlines in a vector field."
       short_help="Integrate streamlines in a vector field.">
The Stream Tracer filter generates streamlines in a vector field from a collection of seed points. The vector field used is selected from the Vectors menu, so the input data set is required to have point-centered vectors. The Seed portion of the interface allows you to select whether the seed points for this integration lie in a point cloud or along a line. Depending on which is selected, the appropriate 3D widget (point or line widget) is displayed along with traditional user interface controls for positioning the point cloud or line within the data set. Instructions for using the 3D widgets and the corresponding manual controls can be found in section 7.4.
The Max. Propagation entry box allows you to specify the maximum length of the streamlines. From the Max. Propagation menu, you can select the units to be either Time (the time a particle would travel with steady flow) or Length (in the data set's spatial coordinates).
The Init. Step Len. menu and entry specify the initial step size for integration. (For non-adaptive integrators, Runge-Kutta 2 and 4, the initial step size is used throughout the integration.) The menu allows you to specify the units. Time and Length have the same meaning as for Max. Propagation. Cell Length specifies the step length as a number of cells.
The Integration Direction menu determines in which direction(s) the stream trace will be generated: FORWARD, BACKWARD, or BOTH.
The Integrator Type section of the interface determines which calculation to use for integration: Runge-Kutta 2, Runge-Kutta 4, or Runge-Kutta 4-5. If Runge-Kutta 4-5 is selected, controls are displayed for specifying the minimum and maximum step length and the maximum error. The controls for specifying Min. Step Len. and Max. Step Len. are the same as those for Init. Step Len. The Runge-Kutta 4-5 integrator tries to choose the step size so that the estimated error is less than the value of the Maximum Error entry.
If the integration takes more than Max. Steps to complete, if the speed goes below Term. Speed, if Max. Propagation is reached, or if a boundary of the input data set is crossed, integration terminates.
This filter operates on any type of data set, provided it has point-centered vectors. The output is polygonal data containing polylines. This filter is available on the Toolbar.
    </Documentation>
    <InputProperty
       name="Input"
       command="AddInputConnection"
       clean_command="RemoveAllInputs"
       multiple_input="1">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type" composite_data_supported="1">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            number_of_components="3"/>
     </InputProperty>

     <InputProperty
        name="Source"
        command="SetSourceConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="sources" name="PointSource" />
              <Proxy group="sources" name="LineSource" />
           </ProxyListDomain>
      </InputProperty>

     <StringVectorProperty 
        name="SelectInputVectors" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        animateable="0"> 
           <ArrayListDomain name="array_list" attribute_type="Vectors">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
     </StringVectorProperty>

     <IntVectorProperty
        name="NumberOfPoints"
        number_of_elements="1"
        default_values="100"
        information_only="1"/>

     <IntVectorProperty 
        name="MaximumPropagationUnit" 
        command="SetMaximumPropagationUnit" 
        number_of_elements="1"
        default_values="1" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumPropagation"
        command="SetMaximumPropagation"
        number_of_elements="1"
        default_values="1.0" >
       <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="1.0">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="InitialIntegrationStepUnit" 
        command="SetInitialIntegrationStepUnit" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
         <Entry value="2" text="Cell Length"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="InitialIntegrationStep"
        command="SetInitialIntegrationStep"
        number_of_elements="1"
        default_values="0.5" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="IntegrationDirection" 
        command="SetIntegrationDirection" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="FORWARD"/>
         <Entry value="1" text="BACKWARD"/>
         <Entry value="2" text="BOTH"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <IntVectorProperty 
        name="IntegratorType" 
        command="SetIntegratorType" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Runge-Kutta 2"/>
         <Entry value="1" text="Runge-Kutta 4"/>
         <Entry value="2" text="Runge-Kutta 4-5"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumError"
        command="SetMaximumError"
        number_of_elements="1"
        default_values="0.000001" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MinimumIntegrationStepUnit" 
        command="SetMinimumIntegrationStepUnit" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
         <Entry value="2" text="Cell Length"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MinimumIntegrationStep"
        command="SetMinimumIntegrationStep"
        number_of_elements="1"
        default_values="0.01" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MaximumIntegrationStepUnit" 
        command="SetMaximumIntegrationStepUnit" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
         <Entry value="2" text="Cell Length"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumIntegrationStep"
        command="SetMaximumIntegrationStep"
        number_of_elements="1"
        default_values="0.01" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MaximumNumberOfSteps" 
        command="SetMaximumNumberOfSteps" 
        number_of_elements="1"
        default_values="2000" >
       <IntRangeDomain name="range"/>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="TerminalSpeed"
        command="SetTerminalSpeed"
        number_of_elements="1"
        default_values="0.000000000001" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End StreamTracer -->
   </SourceProxy>

   <SourceProxy name="StructuredGridOutlineFilter" 
                class="vtkStructuredGridOutlineFilter">
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkStructuredGrid"/>
           </DataTypeDomain>
      </InputProperty>
   <!-- End Balance -->
   </SourceProxy>

   <SourceProxy name="Pick" class="vtkPickFilter">
     <Documentation
        long_help="Find the cell or point closest to the input point."
        short_help="Pick cells or points.">
The Pick filter displays the underlying data nearest to a user-selected point. A point widget, with its usual controls in the display area and on the Parameters tab, is provided for choosing this point. (See section 7.4 for information about using the point widget.) Pressing the "P" key positions the point widget at the point on the data set under the current cursor position. If you select Point from the Pick Type menu, the output of the filter will be the nearest point to the point widget. If you select Cell, the output of the filter is the cell which is closest to the selected point. All the output point-centered attributes, cell-centered attributes, and original ids are displayed on the Parameters tab. Also, the selected cell will be outlined in red in the display area, and the reference ids of the points within that cell will be labeled.
The Pick filter operates on any type of data and produces unstructured grid output.
     </Documentation>
     <InputProperty
        name="Input"
        command="AddInputConnection"
        clean_command="RemoveAllInputs"
        multiple_input="1">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type" composite_data_supported="0">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
      </InputProperty>

      <DoubleVectorProperty
         name="WorldPoint"
         command="SetWorldPoint"
         number_of_elements="3"
         default_values="0 0 0" >
      </DoubleVectorProperty>

     <IntVectorProperty 
        name="PickCell" 
        command="SetPickCell" 
        number_of_elements="1"
        default_values="1" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Point"/>
         <Entry value="1" text="Cell"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <IntVectorProperty 
        name="UseIdToPick" 
        command="SetUseIdToPick" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Off"/>
         <Entry value="1" text="On"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <IntVectorProperty 
        name="Id" 
        command="SetId" 
        number_of_elements="1"
        default_values="0" >
     </IntVectorProperty>

   </SourceProxy>

  <SourceProxy name="GenericClip" class="vtkGenericClip">
    <Documentation
       long_help="Clip with an implicit plane, sphere or with scalars. Clipping does not reduce the dimensionality of the data set.  This output data type of this filter is always an unstructured grid."
       short_help="Clip with an implicit plane, sphere or with scalars.">
The Clip filter cuts away a portion of the input data set using a plane, a sphere, a box, or a scalar value. The menu in the Clip Function portion of the interface allows the user to select which implicit function to use or whether to clip using a scalar value. Making this selection loads the appropriate user interface. For the implicit functions, the appropriate 3D widget (plane, sphere, or box) is also displayed. The use of these 3D widgets, including their user interface components, is discussed in section 7.4.
If an implicit function is selected, the clip filter returns that portion of the input data set that lies inside the function. If Scalars is selected, then the user must specify a scalar array to clip according to. The clip filter will return the portions of the data set whose value in the selected Scalars array is larger than the Clip value. Regardless of the selection from the Clip Function menu, if the Inside Out option is checked, the opposite portions of the data set will be returned.
This filter operates on all types of data sets, and it returns unstructured grid data on output. This filter is available on the toolbar.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkGenericDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            optional="1"/>
     </InputProperty>

     <ProxyProperty name="ClipFunction" command="SetClipFunction">
           <ProxyGroupDomain name="groups">
               <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="Plane" />
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
           </ProxyListDomain>
     </ProxyProperty>

     <DoubleVectorProperty
        name="InputBounds"  information_only="1">
       <BoundsDomain name="bounds">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="InsideOut" 
        command="SetInsideOut" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="Value"
        command="SetValue"
        number_of_elements="1"
        default_values="0.0" >
          <ArrayRangeDomain name="scalar_range">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayRangeDomain>         
          <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>
   <!-- End GenericClip -->
   </SourceProxy>

   <SourceProxy name="GenericContour" class="vtkGenericContourFilter">
    <Documentation
       long_help="Generate isolines or isosurfaces using point scalars."
       short_help="Generate isolines or isosurfaces.">
The Contour filter computes isolines or isosurfaces using a selected point-centered scalar array. The available scalar arrays are listed in the Scalars menu. The scalar range of the selected array will be displayed.
The interface for adding contour values is very similar to the one for selecting cut offsets (in the Cut filter). To add a single contour value, select the value from the New Value slider in the Add value portion of the interface and click the Add button, or press Enter. To instead add several evenly spaced contours, use the controls in the Generate range of values section. Select the number of contour values to generate using the Number of Values slider. The Range slider controls the interval in which to generate the contour values. Once the number of values and range have been selected, click the Generate button. The new values will be added to the Contour Values list. To delete a value from the Contour Values list, select the value and click the Delete button. (If no value is selected, the last value in the list will be removed.) Clicking the Delete All button removes all the values in the list. If no values are in the Contour Values list when Accept is pressed, the current value of the New Value slider will be used.
In addition to selecting contour values, you can also select additional computations to perform. If any of Compute Normals, Compute Gradients, or Compute Scalars is selected, the appropriate computation will be performed, and a corresponding point-centered array will be added to the output.
The Contour filter operates on any type of data set, but the input is required to have at least one point-centered scalar (single-component) array. The output of this filter is polygonal. This filter is available on the Toolbar.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkGenericDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            number_of_components="1" optional="1"/>
     </InputProperty>

     <DoubleVectorProperty
        name="ContourValues"
        command="SetValue"
        set_number_command="SetNumberOfContours"
        number_of_elements="0"
        repeat_command="1"
        number_of_elements_per_command="1"
        use_index="1"
        animateable="1">
          <ArrayRangeDomain name="scalar_range">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayRangeDomain>         
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="ComputeNormals" 
        command="SetComputeNormals" 
        number_of_elements="1"
        default_values="1" 
        animateable="0"> 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ComputeGradients" 
        command="SetComputeGradients" 
        number_of_elements="1"
        default_values="0" 
        animateable="0"> 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ComputeScalars" 
        command="SetComputeScalars" 
        number_of_elements="1"
        default_values="0" 
        animateable="0"> 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End GenericContour -->
   </SourceProxy>

 <SourceProxy name="GenericCut" class="vtkGenericCutter">
    <Documentation
       long_help="This filter cuts a data set with a plane or sphere.  Cutting is similar to a contour.  It creates surfaces from volumes and lines from surfaces."
       short_help="Cut datasets with planes or spheres.">
The Cut filter extracts the portion of the input data set that lies along the specified plane or sphere. From the Cut Function menu, you can select whether cutting will be performed with a plane or a sphere. The appropriate 3D widget (plane widget or sphere widget) will be displayed. The parameters of the cut function can be specified interactively using the 3D widget or manually using the traditional user interface controls. Instructions for using these 3D widgets and their corresponding user interfaces are found in section 7.4.
By default, the cut lies on the specified plane or sphere. Using the Cut Offset Values portion of the interface, it is also possible to cut the data set at some offset from the original cut function. The Cut Offset Values are in the spatial units of the data set. To add a single offset, select the value from the New Value slider in the Add value portion of the interface and click the Add button, or press Enter. To instead add several evenly spaced offsets, use the controls in the Generate range of values section. Select the number of offsets to generate using the Number of Values slider. The Range slider controls the interval in which to generate the offsets. Once the number of values and range have been selected, click the Generate button. The new offsets will be added to the Offset Values list. To delete a value from the Cut Offset Values list, select the value and click the Delete button. (If no value is selected, the last value in the list will be removed.) Clicking the Delete All button removes all the values in the list.
The Cut filter takes any type of data set as input. Use the Input menu to choose a data set to cut. The output of this filter is polygonal data. This filter is available on the Toolbar.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkGenericDataSet"/>
          </DataTypeDomain>
     </InputProperty>

     <ProxyProperty name="CutFunction" command="SetCutFunction">
           <ProxyGroupDomain name="groups">
              <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="Plane" />
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
           </ProxyListDomain>
     </ProxyProperty>

     <DoubleVectorProperty
        name="InputBounds"  information_only="1">
       <BoundsDomain name="bounds">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="ContourValues"
        command="SetValue"
        repeat_command="1"
        set_number_command="SetNumberOfContours"
        number_of_elements_per_command="1"
        use_index="1"
        animateable="1">
          <BoundsDomain name="bounds" mode="magnitude">
            <RequiredProperties>
              <Property name="Input" function="Input"/>
            </RequiredProperties>
          </BoundsDomain>
     </DoubleVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End GenericCut -->
   </SourceProxy>

  <SourceProxy name="GenericGeometryFilter" class="vtkGenericGeometryFilter">
     <Documentation
         long_help="Extract geometry from a higher-order dataset"
         short_help="Extract geometry from a higher-order dataset">
Extract geometry from a higher-order dataset.
     </Documentation>
     <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkGenericDataSet"/>
           </DataTypeDomain>
      </InputProperty>

   <!-- End GenericGeometryFilter -->
   </SourceProxy>

 <SourceProxy name="GenericOutlineFilter" class="vtkGenericOutlineFilter">
     <Documentation
       long_help="This filter generates a bounding box representation of the input."
       short_help="Generates a bounding box.">
The Outline filter generates an axis-aligned bounding box for the input data set. The Input menu specifies the data set for which to create a bounding box. This filter operates on any type of data set and produces polygonal output.
     </Documentation>
      
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkGenericDataSet"/>
           </DataTypeDomain>
      </InputProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End  GenericOutlineFilter -->
   </SourceProxy>

 <SourceProxy name="GenericStreamTracer" class="vtkGenericStreamTracer">
    <Documentation
       long_help="Integrate streamlines in a vector field."
       short_help="Integrate streamlines in a vector field.">
The Stream Tracer filter generates streamlines in a vector field from a collection of seed points. The vector field used is selected from the Vectors menu, so the input data set is required to have point-centered vectors. The Seed portion of the interface allows you to select whether the seed points for this integration lie in a point cloud or along a line. Depending on which is selected, the appropriate 3D widget (point or line widget) is displayed along with traditional user interface controls for positioning the point cloud or line within the data set. Instructions for using the 3D widgets and the corresponding manual controls can be found in section 7.4.
The Max. Propagation entry box allows you to specify the maximum length of the streamlines. From the Max. Propagation menu, you can select the units to be either Time (the time a particle would travel with steady flow) or Length (in the data set's spatial coordinates).
The Init. Step Len. menu and entry specify the initial step size for integration. (For non-adaptive integrators, Runge-Kutta 2 and 4, the initial step size is used throughout the integration.) The menu allows you to specify the units. Time and Length have the same meaning as for Max. Propagation. Cell Length specifies the step length as a number of cells.
The Integration Direction menu determines in which direction(s) the stream trace will be generated: FORWARD, BACKWARD, or BOTH.
The Integrator Type section of the interface determines which calculation to use for integration: Runge-Kutta 2, Runge-Kutta 4, or Runge-Kutta 4-5. If Runge-Kutta 4-5 is selected, controls are displayed for specifying the minimum and maximum step length and the maximum error. The controls for specifying Min. Step Len. and Max. Step Len. are the same as those for Init. Step Len. The Runge-Kutta 4-5 integrator tries to choose the step size so that the estimated error is less than the value of the Maximum Error entry.
If the integration takes more than Max. Steps to complete, if the speed goes below Term. Speed, if Max. Propagation is reached, or if a boundary of the input data set is crossed, integration terminates.
This filter operates on any type of data set, provided it has point-centered vectors. The output is polygonal data containing polylines. This filter is available on the Toolbar.
    </Documentation>
       
    <InputProperty
       name="Input"
       command="AddInputConnection"
       clean_command="RemoveAllInputs"
       multiple_input="1">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkGenericDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            number_of_components="3"/>
     </InputProperty>

     <InputProperty
        name="Source"
        command="SetSourceConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
           </ProxyGroupDomain>
         <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
      </InputProperty>

     <!-- This is a hack used to bypass the fact that ParaView
          does not have special proxies for things like point sources.
          It should be removed in the future -->
     <!-- TODO: Should this be removed now? -->
     <DoubleVectorProperty
        name="Radius"
        number_of_elements="1"
        default_values="0.1"
        information_only="1">
        <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="0.1">
          <RequiredProperties>
             <Property name="Input" function="Input"/>
          </RequiredProperties>
        </BoundsDomain>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="NumberOfPoints"
        number_of_elements="1"
        default_values="100"
        information_only="1"/>

     <IntVectorProperty 
        name="MaximumPropagationUnit" 
        command="SetMaximumPropagationUnit" 
        number_of_elements="1"
        default_values="1" >
       <EnumerationDomain>
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumPropagation"
        command="SetMaximumPropagation"
        number_of_elements="1"
        default_values="1.0" >
       <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="1.0">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="InitialIntegrationStepUnit" 
        command="SetInitialIntegrationStepUnit" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain>
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
         <Entry value="2" text="Cell Length"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="InitialIntegrationStep"
        command="SetInitialIntegrationStep"
        number_of_elements="1"
        default_values="0.5" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="IntegrationDirection" 
        command="SetIntegrationDirection" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain>
         <Entry value="0" text="FORWARD"/>
         <Entry value="1" text="BACKWARD"/>
         <Entry value="2" text="BOTH"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <IntVectorProperty 
        name="IntegratorType" 
        command="SetIntegratorType" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain>
         <Entry value="0" text="Runge-Kutta 2"/>
         <Entry value="1" text="Runge-Kutta 4"/>
         <Entry value="2" text="Runge-Kutta 4-5"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumError"
        command="SetMaximumError"
        number_of_elements="1"
        default_values="0.000001" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MinimumIntegrationStepUnit" 
        command="SetMinimumIntegrationStepUnit" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain>
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
         <Entry value="2" text="Cell Length"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MinimumIntegrationStep"
        command="SetMinimumIntegrationStep"
        number_of_elements="1"
        default_values="0.01" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MaximumIntegrationStepUnit" 
        command="SetMaximumIntegrationStepUnit" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain>
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
         <Entry value="2" text="Cell Length"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumIntegrationStep"
        command="SetMaximumIntegrationStep"
        number_of_elements="1"
        default_values="0.01" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MaximumNumberOfSteps" 
        command="SetMaximumNumberOfSteps" 
        number_of_elements="1"
        default_values="2000" >
       <IntRangeDomain name="range"/>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="TerminalSpeed"
        command="SetTerminalSpeed"
        number_of_elements="1"
        default_values="0.000000000001" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End GenericStreamTracer -->
   </SourceProxy>

  <SourceProxy name="GenericTessellator" class="vtkGenericDataSetTessellator">
     <Documentation
         long_help="Tessellate a higher-order dataset"
         short_help="Tessellate a higher-order dataset">
Tessellate a higher-order dataset.
     </Documentation>
     <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkGenericDataSet"/>
           </DataTypeDomain>
      </InputProperty>

   <!-- End GenericTessellator -->
   </SourceProxy>

   <SourceProxy name="GroupDataSets" class="vtkMultiGroupDataGroupFilter">
    <Documentation
        long_help="Group data sets."
        short_help="Group multiple inputs into one collection.">
Groups multiple datasets to create a multigroup dataset
     </Documentation>
     <InputProperty
        name="Input"
        command="AddInputConnection"
        clean_command="RemoveAllInputs"
        multiple_input="1">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type" composite_data_supported="1">
             <DataType value="vtkDataObject"/>
           </DataTypeDomain>
     </InputProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End GroupDataSets -->
   </SourceProxy>

   <SourceProxy name="GroupIdScalars" class="vtkMultiGroupDataGroupIdScalars">
     <Documentation
        long_help="This filter uses colors to show levels of a hiearchical dataset."
        short_help="Generate point scalars from level.">
This filter uses colors to show levels of a hiearchical dataset.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkMultiGroupDataSet"/>
           </DataTypeDomain>
     </InputProperty>
   <!-- End GroupIdScalars -->
   </SourceProxy>

    <SourceProxy name="GeometryFilter" class="vtkPVGeometryFilter">
      <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <!-- Does this have any data type domain? -->
      </InputProperty>
      <IntVectorProperty
        name="UseStrips"
        command="SetUseStrips"
        number_of_elements="1"
        default_values="0"
        animateable="0">
        <BooleanDomain name="bool"/> 
      </IntVectorProperty>
      <IntVectorProperty
        name="UseOutline"
        command="SetUseOutline"
        number_of_elements="1"
        default_values="0"
        animateable="0">
        <BooleanDomain name="bool"/>
      </IntVectorProperty>
      <IntVectorProperty
        name="PassThroughIds"
        command="SetPassThroughCellIds"
        number_of_elements="1"
        default_values="1"
        animateable="0">
        <BooleanDomain name="bool"/> 
      </IntVectorProperty>
    <!-- End GeometryFilter -->
    </SourceProxy>

    <SourceProxy name="OrderedCompositeDistributor"
                 class="vtkOrderedCompositeDistributor">
      <InputProperty name="Input" command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
      </InputProperty>
      <IntVectorProperty name="PassThrough"
                         command="SetPassThrough"
                         number_of_elements="1"
                         default_values="0"
                         animateable="0">
        <BooleanDomain name="bool"/>
      </IntVectorProperty>
      <ProxyProperty name="PKdTree" command="SetPKdTree">
        <ProxyGroupDomain name="groups">
          <Group name="locators"/>
        </ProxyGroupDomain>
      </ProxyProperty>
      <StringVectorProperty name="OutputType"
                            command="SetOutputType"
                            number_of_elements="1">
      </StringVectorProperty>
    <!-- End OrderedCompositeDistributor -->
    </SourceProxy>

    <UpdateSuppressorProxy name="UpdateSuppressor" class="vtkPVUpdateSuppressor"
      executive="vtkUpdateSuppressorPipeline">
      <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <!-- Does this have any data type domain? -->
      </InputProperty>
      <Property
        name="ForceUpdate"
        command="ForceUpdate"
        is_internal="1">
      </Property>
      <Property
        name="RemoveAllCaches"
        command="RemoveAllCaches"
        immediate_update="1">
      </Property>
      <IntVectorProperty
        name="CacheUpdate"
        command="CacheUpdate"
        number_of_elements="2"
        default_values="0 -1"
        is_internal="1">
        <IntRangeDomain name="range" min="0 -1" />
      </IntVectorProperty>
      <IntVectorProperty
        name="Enabled"
        command="SetEnabled"
        number_of_elements="1"
        default_values="1">
        <BooleanDomain name="bool" />
      </IntVectorProperty>
    <!-- End UpdateSuppressor -->
    </UpdateSuppressorProxy>
    
    <SourceProxy name="MPIMoveData" class="vtkMPIMoveData">
      <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <!-- Does this have any data type domain? -->
      </InputProperty>
      <IntVectorProperty
        name="MoveMode"
        command="SetMoveMode"
        number_of_elements="1"
        default_values="0"
        animateable="0">
        <EnumerationDomain name="enum">
          <Entry value="0" text="PassThrough" />
          <Entry value="1" text="Collect" />
          <Entry value="2" text="Clone" />
        </EnumerationDomain>
      </IntVectorProperty>
      <IntVectorProperty
        name="OutputDataType"
        command="SetOutputDataType"
        number_of_elements="1"
        default_values="0"
        animateable="0">
        <EnumerationDomain name="enum">
          <Entry value="0" text="PolyData" />
          <Entry value="4" text="Unstructured Grid" />
        </EnumerationDomain>
      </IntVectorProperty>
    <!-- End MPIMoveData -->
    </SourceProxy>

    <SourceProxy name="ClientServerMoveData" class="vtkClientServerMoveData">
      <InputProperty name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
      </InputProperty>
    <!-- End ClientServerMoveData -->
    </SourceProxy>
        
    <SourceProxy name="ReductionFilter" class="vtkReductionFilter">
      <InputProperty name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
      </InputProperty>
      <ProxyProperty name="ReductionHelper"
         command="SetReductionHelper">
      </ProxyProperty>
    <!-- End ReductionFilter -->
    </SourceProxy>

   <SourceProxy name="ExtractOneDataSet" class="vtkMultiGroupDataExtractOne">
     <Documentation
        long_help="This filter extracts the first dataset from a composite dataset and produces a simple dataset as output. Use this filter before filters that do not work with composite datasets"
        short_help="Convert to simple dataset.">
This filter extracts a range of groups from a multigroup dataset    
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkMultiGroupDataSet"/>
           </DataTypeDomain>
     </InputProperty>
   <!-- End ExtractOneDataSet -->
   </SourceProxy>

   <SourceProxy name="ExtractLevel" class="vtkMultiGroupDataExtractGroup">
     <Documentation
        long_help="This filter extracts a range of groups from a multigroup dataset."
        short_help="Extract level.">
This filter extracts a range of groups from a multigroup dataset    
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkMultiGroupDataSet"/>
           </DataTypeDomain>
           <NumberOfGroupsDomain name="multi_group" multiplicity="multiple"/>
     </InputProperty>

     <IntVectorProperty 
        name="GroupRange" 
        command="SetGroupRange" 
        number_of_elements="2"
        default_values="0 0" > 
       <NumberOfGroupsDomain name="range">
          <RequiredProperties>
             <Property name="Input" function="Input"/>
          </RequiredProperties>
       </NumberOfGroupsDomain>
     </IntVectorProperty>
   <!-- End ExtractLevel -->
   </SourceProxy>

   <SourceProxy name="ExtractDataSets" 
                class="vtkMultiGroupDataExtractDataSets">
     <Documentation
        long_help="This filter extracts a list of datasets from multigroup datasets."
        short_help="Extract datasets.">
This filter extracts a list of datasets from multigroup datasets.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkMultiGroupDataSet"/>
           </DataTypeDomain>
     </InputProperty>

     <IntVectorProperty 
        name="SelectedDataSets" 
        command="AddDataSet"
        clean_command="ClearDataSetList"
        repeat_command="1"
        number_of_elements_per_command="2"/>
   <!-- End ExtractDataSets -->
   </SourceProxy>

   <ShrunkContoursProxy name="ShrunkContours" class="vtkContourFilter"
        base_proxygroup="filters" base_proxyname="Contour">
      <SubProxy>
        <Proxy name="Shrink" proxygroup="filters" proxyname="ShrinkFilter" >
        </Proxy>
        <ExposedProperties>
          <Property name="ShrinkFactor" />
        </ExposedProperties>
      </SubProxy>
   <!-- End ShrunkContours -->
   </ShrunkContoursProxy>

   
   <SourceProxy name="TemporalCache" class="vtkTemporalCacheFilter">
     <InputProperty name="Input" command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkPointSet"/>
       </DataTypeDomain>
     </InputProperty>

     <IntVectorProperty 
        name="UseCache" 
        command="SetUseCache" 
        number_of_elements="1"
        default_values="0" > 
        <BooleanDomain name="bool" />
     </IntVectorProperty>

     <IntVectorProperty 
        name="AttributeToCollect"
        command="SetAttributeToCollect"
        number_of_elements="1"
        default_values="0">
        <EnumerationDomain name="enum">
          <Entry value="0" text="PointData" />
          <Entry value="1" text="CellData" />
          <Entry value="2" text="FieldData" />
        </EnumerationDomain>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="CollectAttributeData"
        command="CollectAttributeData"
        number_of_elements="1"
        default_values="0">
     </DoubleVectorProperty>

     <Property
        name="ClearCache"
        command="ClearCache"
        immediate_update="1">
     </Property>
   <!-- End TemporalCache -->
   </SourceProxy>
   
   <SourceProxy name="CellSelect" class="vtkFrustumExtractor">
      <Documentation
        long_help="Draw a rectangle on the screen and obtain the section of data inside it." 
        short_help="Rubber band selection inside a DataSet">
Click the Start Selection button to begin. Then use the left mouse button to make a selection rectangle on the render window. The portion of the input data set that lies within the volume in space behind the selection rectangle will be returned.
      </Documentation>

     <InputProperty name="Input" command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkDataSet"/>
       </DataTypeDomain>
     </InputProperty>

     <IntVectorProperty 
        name="ExactTest" 
        command="SetExactTest" 
        number_of_elements="1"
        default_values="1" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Off"/>
         <Entry value="1" text="On"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <IntVectorProperty 
        name="PassThrough" 
        command="SetPassThrough" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Off"/>
         <Entry value="1" text="On"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="CreateFrustum"
        command="CreateFrustum"
        number_of_elements="32"
        is_internal="1"
        argument_is_array="1"
        default_values=
        "0.0 0.0 0.0 0.0
         0.0 0.0 0.0 0.0
         0.0 0.0 0.0 0.0
         0.0 0.0 0.0 0.0
         0.0 0.0 0.0 0.0
         0.0 0.0 0.0 0.0
         0.0 0.0 0.0 0.0
         0.0 0.0 0.0 0.0">
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="ShowBounds" 
        command="SetShowBounds" 
        number_of_elements="1"
        is_internal="1"
        default_values="0">
       <EnumerationDomain name="enum">
         <Entry value="0" text="Off"/>
         <Entry value="1" text="On"/>
       </EnumerationDomain>
     </IntVectorProperty>
     
   <!-- End CellSelect -->
   </SourceProxy>

   <SourceProxy name="TestCut" class="vtkCutter">
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
     </InputProperty>

     <ProxyProperty name="CutFunction" command="SetCutFunction">
           <ProxyGroupDomain name="groups">
              <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="Plane" />
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
           </ProxyListDomain>
     </ProxyProperty>

     <DoubleVectorProperty
        name="InputBounds" information_only="1">
       <BoundsDomain name="bounds">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
     </DoubleVectorProperty>

     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End TestCut -->
   </SourceProxy>

   <SourceProxy name="ExtractHistogram" class="vtkExtractHistogram">
     <Documentation
        long_help="Extract a histogram from field data."
        short_help="Extract a histogram from field data.">
     </Documentation>
    
     <InputProperty name="Input" command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array">
             <RequiredProperties>
                <Property name="SelectInputArray" 
                          function="FieldDataSelection"/>
             </RequiredProperties>
          </InputArrayDomain>
     </InputProperty>

     <StringVectorProperty
         name="SelectInputArray" 
         command="SetInputArrayToProcess" 
         number_of_elements="5" 
         element_types="0 0 0 0 2" 
         animateable="0"> 
          <ArrayListDomain name="array_list" 
                           attribute_type="Scalars">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
          <FieldDataDomain name="field_list">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </FieldDataDomain>
     </StringVectorProperty>

     <IntVectorProperty name="BinCount" command="SetBinCount" number_of_elements="1" default_values="10" animateable="0"> 
        <IntRangeDomain name="range" min="1" max="256"/>
     </IntVectorProperty>

     <IntVectorProperty name="Component" command="SetComponent" number_of_elements="1" default_values="0" animateable="0"> 
        <IntRangeDomain name="range" min="0" max="15"/>
     </IntVectorProperty>

   <!-- End ExtractHistogram -->
   </SourceProxy>

   
   <SourceProxy name="RectilinearGridGeometryFilter" class="vtkRectilinearGridGeometryFilter">
      <Documentation
         long_help="Extracts geometry for a rectilinear grid.  Output is a polydata dataset."
         short_help="Extracts geometry for a rectilinear grid.">
         RectilinearGridGeometryFilter is a filter that extracts geometry from a rectilinear grid. By specifying appropriate i-j-k indices, it is possible to extract a point, a curve, a surface, or a "volume".  The volume is actually a (n x m x o) region of points.  The extent specification is zero-offset.  That is, the first k-plane in a 50x50x50 rectilinear grid is given by (0,49, 0,49, 0,0).
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
      </InputProperty>
         
   <!-- End RectilinearGridGeometryFilter -->
   </SourceProxy>

   <SourceProxy name="AttributeEditor" class="vtkAttributeEditor">
     <Documentation
          long_help="Select with a point or box widget the region to edit.  This output data type of this filter is always an unstructured grid."
          short_help="Select with a point or box widget the region to edit.">
The Attribute Editor filter selects a portion of the input data set using a box. The menu in the Clip Function portion of the interface allows the user to select which implicit function to use or whether to clip using a scalar value. Making this selection loads the appropriate user interface. For the implicit functions, the appropriate 3D widget is also displayed. The use of these 3D widgets, including their user interface components, is discussed in section 7.4.
If an implicit function is selected, the clip filter returns that portion of the input data set that lies inside the function.  The filter will return the portions of the data set whose value in the selected Scalars array is larger than the Clip value. Regardless of the selection from the Clip Function menu, if the Inside Out option is checked, the opposite portions of the data set will be returned.
This filter operates on all types of data sets, and it returns unstructured grid data on output. This filter is available on the toolbar.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
          <InputArrayDomain name="input_array" number_of_components="1">
          </InputArrayDomain>
      </InputProperty>

     <InputProperty
        name="Source"
        command="SetSourceConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
      </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2">
           <ArrayListDomain name="array_list" attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
     </StringVectorProperty> 

     <ProxyProperty name="PickFunction" command="SetPickFunction">
           <ProxyGroupDomain name="groups">
               <Group name="implicit_functions"/>
               <Group name="3d_widgets"/>
           </ProxyGroupDomain>
     </ProxyProperty>

     <DoubleVectorProperty
        name="Value"
        command="SetAttributeValue"
        number_of_elements="1"
        default_values="0.0" >
          <ArrayRangeDomain name="scalar_range">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
               <Property name="SelectInputScalars" function="ArraySelection"/>
            </RequiredProperties>
          </ArrayRangeDomain>         
     </DoubleVectorProperty>

      <DoubleVectorProperty
         name="WorldPoint"
         command="SetWorldPoint"
         number_of_elements="3"
         default_values="0 0 0" >
      </DoubleVectorProperty>  
   
     <IntVectorProperty 
        name="EditMode" 
        command="SetEditMode" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ClearEdits" 
        command="SetClearEdits" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <IntVectorProperty 
        name="UnfilteredDataset" 
        command="SetUnfilteredDataset" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
   <!-- End AttributeEditor -->
   </SourceProxy>

   <SourceProxy name="CellSelect2" class="vtkCellSelect">
     <Documentation
        long_help="testing"
        short_help="testing">
        Testing.
     </Documentation>

     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
      </InputProperty>
      <Hints>
        <Visibility replace_input="0" />
      </Hints>
   <!-- End CellSelect2 -->
   </SourceProxy>

   <SourceProxy name="TextureMapToPlane" class="vtkTextureMapToPlane">
     <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
     </InputProperty>
   <!-- End TextureMapToPlane -->
   </SourceProxy>

   <SourceProxy name="TextureMapToSphere" class="vtkTextureMapToSphere">
     <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
     </InputProperty>
   <!-- End TextureMapToSphere -->
   </SourceProxy>

   <SourceProxy name="TextureMapToCylinder" class="vtkTextureMapToCylinder">
     <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
     </InputProperty>
   <!-- End TextureMapToCylinder -->
   </SourceProxy>

   <SourceProxy name="PolyLineToRectilinearGrid" class="vtkPolyLineToRectilinearGridFilter">
      <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
     </InputProperty>     
   </SourceProxy>
   
   </ProxyGroup>

</ServerManagerConfiguration>

